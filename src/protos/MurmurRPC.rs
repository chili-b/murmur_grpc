// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `murmur/MurmurRPC.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct Void {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Void {
    fn default() -> &'a Void {
        <Void as ::protobuf::Message>::default_instance()
    }
}

impl Void {
    pub fn new() -> Void {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Void {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Void {
        Void::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Void>(
                "Void",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Void {
        static instance: ::protobuf::rt::LazyV2<Void> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Void::new)
    }
}

impl ::protobuf::Clear for Void {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Void {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Void {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Version {
    // message fields
    version: ::std::option::Option<u32>,
    release: ::protobuf::SingularField<::std::string::String>,
    os: ::protobuf::SingularField<::std::string::String>,
    os_version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as ::protobuf::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string release = 2;


    pub fn get_release(&self) -> &str {
        match self.release.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_release(&mut self) {
        self.release.clear();
    }

    pub fn has_release(&self) -> bool {
        self.release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: ::std::string::String) {
        self.release = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release(&mut self) -> &mut ::std::string::String {
        if self.release.is_none() {
            self.release.set_default();
        }
        self.release.as_mut().unwrap()
    }

    // Take field
    pub fn take_release(&mut self) -> ::std::string::String {
        self.release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os = 3;


    pub fn get_os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string os_version = 4;


    pub fn get_os_version(&self) -> &str {
        match self.os_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_os_version(&mut self) {
        self.os_version.clear();
    }

    pub fn has_os_version(&self) -> bool {
        self.os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version(&mut self) -> &mut ::std::string::String {
        if self.os_version.is_none() {
            self.os_version.set_default();
        }
        self.os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        self.os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Version {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.release)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.release.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.os_version.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.release.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.os.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.os_version.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Version {
        Version::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &Version| { &m.version },
                |m: &mut Version| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "release",
                |m: &Version| { &m.release },
                |m: &mut Version| { &mut m.release },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os",
                |m: &Version| { &m.os },
                |m: &mut Version| { &mut m.os },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "os_version",
                |m: &Version| { &m.os_version },
                |m: &mut Version| { &mut m.os_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Version>(
                "Version",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Version {
        static instance: ::protobuf::rt::LazyV2<Version> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Version::new)
    }
}

impl ::protobuf::Clear for Version {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.release.clear();
        self.os.clear();
        self.os_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uptime {
    // message fields
    secs: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Uptime {
    fn default() -> &'a Uptime {
        <Uptime as ::protobuf::Message>::default_instance()
    }
}

impl Uptime {
    pub fn new() -> Uptime {
        ::std::default::Default::default()
    }

    // optional uint64 secs = 1;


    pub fn get_secs(&self) -> u64 {
        self.secs.unwrap_or(0)
    }
    pub fn clear_secs(&mut self) {
        self.secs = ::std::option::Option::None;
    }

    pub fn has_secs(&self) -> bool {
        self.secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secs(&mut self, v: u64) {
        self.secs = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Uptime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.secs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secs {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secs {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uptime {
        Uptime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "secs",
                |m: &Uptime| { &m.secs },
                |m: &mut Uptime| { &mut m.secs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Uptime>(
                "Uptime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Uptime {
        static instance: ::protobuf::rt::LazyV2<Uptime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Uptime::new)
    }
}

impl ::protobuf::Clear for Uptime {
    fn clear(&mut self) {
        self.secs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uptime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uptime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server {
    // message fields
    id: ::std::option::Option<u32>,
    running: ::std::option::Option<bool>,
    pub uptime: ::protobuf::SingularPtrField<Uptime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server {
    fn default() -> &'a Server {
        <Server as ::protobuf::Message>::default_instance()
    }
}

impl Server {
    pub fn new() -> Server {
        ::std::default::Default::default()
    }

    // required uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bool running = 2;


    pub fn get_running(&self) -> bool {
        self.running.unwrap_or(false)
    }
    pub fn clear_running(&mut self) {
        self.running = ::std::option::Option::None;
    }

    pub fn has_running(&self) -> bool {
        self.running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: bool) {
        self.running = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.Uptime uptime = 3;


    pub fn get_uptime(&self) -> &Uptime {
        self.uptime.as_ref().unwrap_or_else(|| <Uptime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_uptime(&mut self) {
        self.uptime.clear();
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: Uptime) {
        self.uptime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uptime(&mut self) -> &mut Uptime {
        if self.uptime.is_none() {
            self.uptime.set_default();
        }
        self.uptime.as_mut().unwrap()
    }

    // Take field
    pub fn take_uptime(&mut self) -> Uptime {
        self.uptime.take().unwrap_or_else(|| Uptime::new())
    }
}

impl ::protobuf::Message for Server {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.uptime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.running = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.uptime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.running {
            my_size += 2;
        }
        if let Some(ref v) = self.uptime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.running {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.uptime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server {
        Server::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Server| { &m.id },
                |m: &mut Server| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "running",
                |m: &Server| { &m.running },
                |m: &mut Server| { &mut m.running },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uptime>>(
                "uptime",
                |m: &Server| { &m.uptime },
                |m: &mut Server| { &mut m.uptime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server>(
                "Server",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server {
        static instance: ::protobuf::rt::LazyV2<Server> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server::new)
    }
}

impl ::protobuf::Clear for Server {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.running = ::std::option::Option::None;
        self.uptime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server_Event {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    field_type: ::std::option::Option<Server_Event_Type>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub message: ::protobuf::SingularPtrField<TextMessage>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server_Event {
    fn default() -> &'a Server_Event {
        <Server_Event as ::protobuf::Message>::default_instance()
    }
}

impl Server_Event {
    pub fn new() -> Server_Event {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.Server.Event.Type type = 2;


    pub fn get_field_type(&self) -> Server_Event_Type {
        self.field_type.unwrap_or(Server_Event_Type::UserConnected)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Server_Event_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.User user = 3;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.TextMessage message = 4;


    pub fn get_message(&self) -> &TextMessage {
        self.message.as_ref().unwrap_or_else(|| <TextMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: TextMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut TextMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> TextMessage {
        self.message.take().unwrap_or_else(|| TextMessage::new())
    }

    // optional .MurmurRPC.Channel channel = 5;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }
}

impl ::protobuf::Message for Server_Event {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server_Event {
        Server_Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Server_Event| { &m.server },
                |m: &mut Server_Event| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Server_Event_Type>>(
                "type",
                |m: &Server_Event| { &m.field_type },
                |m: &mut Server_Event| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &Server_Event| { &m.user },
                |m: &mut Server_Event| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextMessage>>(
                "message",
                |m: &Server_Event| { &m.message },
                |m: &mut Server_Event| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &Server_Event| { &m.channel },
                |m: &mut Server_Event| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server_Event>(
                "Server.Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server_Event {
        static instance: ::protobuf::rt::LazyV2<Server_Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server_Event::new)
    }
}

impl ::protobuf::Clear for Server_Event {
    fn clear(&mut self) {
        self.server.clear();
        self.field_type = ::std::option::Option::None;
        self.user.clear();
        self.message.clear();
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server_Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Server_Event_Type {
    UserConnected = 0,
    UserDisconnected = 1,
    UserStateChanged = 2,
    UserTextMessage = 3,
    ChannelCreated = 4,
    ChannelRemoved = 5,
    ChannelStateChanged = 6,
}

impl ::protobuf::ProtobufEnum for Server_Event_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Server_Event_Type> {
        match value {
            0 => ::std::option::Option::Some(Server_Event_Type::UserConnected),
            1 => ::std::option::Option::Some(Server_Event_Type::UserDisconnected),
            2 => ::std::option::Option::Some(Server_Event_Type::UserStateChanged),
            3 => ::std::option::Option::Some(Server_Event_Type::UserTextMessage),
            4 => ::std::option::Option::Some(Server_Event_Type::ChannelCreated),
            5 => ::std::option::Option::Some(Server_Event_Type::ChannelRemoved),
            6 => ::std::option::Option::Some(Server_Event_Type::ChannelStateChanged),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Server_Event_Type] = &[
            Server_Event_Type::UserConnected,
            Server_Event_Type::UserDisconnected,
            Server_Event_Type::UserStateChanged,
            Server_Event_Type::UserTextMessage,
            Server_Event_Type::ChannelCreated,
            Server_Event_Type::ChannelRemoved,
            Server_Event_Type::ChannelStateChanged,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Server_Event_Type>("Server.Event.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Server_Event_Type {
}

impl ::std::default::Default for Server_Event_Type {
    fn default() -> Self {
        Server_Event_Type::UserConnected
    }
}

impl ::protobuf::reflect::ProtobufValue for Server_Event_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server_Query {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server_Query {
    fn default() -> &'a Server_Query {
        <Server_Query as ::protobuf::Message>::default_instance()
    }
}

impl Server_Query {
    pub fn new() -> Server_Query {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Server_Query {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server_Query {
        Server_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server_Query>(
                "Server.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server_Query {
        static instance: ::protobuf::rt::LazyV2<Server_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server_Query::new)
    }
}

impl ::protobuf::Clear for Server_Query {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Server_List {
    // message fields
    pub servers: ::protobuf::RepeatedField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Server_List {
    fn default() -> &'a Server_List {
        <Server_List as ::protobuf::Message>::default_instance()
    }
}

impl Server_List {
    pub fn new() -> Server_List {
        ::std::default::Default::default()
    }

    // repeated .MurmurRPC.Server servers = 1;


    pub fn get_servers(&self) -> &[Server] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<Server> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Server_List {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Server_List {
        Server_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "servers",
                |m: &Server_List| { &m.servers },
                |m: &mut Server_List| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Server_List>(
                "Server.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Server_List {
        static instance: ::protobuf::rt::LazyV2<Server_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Server_List::new)
    }
}

impl ::protobuf::Clear for Server_List {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Server_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Server_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    field_type: ::std::option::Option<Event_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.Event.Type type = 2;


    pub fn get_field_type(&self) -> Event_Type {
        self.field_type.unwrap_or(Event_Type::ServerStopped)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Event_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Event| { &m.server },
                |m: &mut Event| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Event_Type>>(
                "type",
                |m: &Event| { &m.field_type },
                |m: &mut Event| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.server.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Event_Type {
    ServerStopped = 0,
    ServerStarted = 1,
}

impl ::protobuf::ProtobufEnum for Event_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Event_Type> {
        match value {
            0 => ::std::option::Option::Some(Event_Type::ServerStopped),
            1 => ::std::option::Option::Some(Event_Type::ServerStarted),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Event_Type] = &[
            Event_Type::ServerStopped,
            Event_Type::ServerStarted,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Event_Type>("Event.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Event_Type {
}

impl ::std::default::Default for Event_Type {
    fn default() -> Self {
        Event_Type::ServerStopped
    }
}

impl ::protobuf::reflect::ProtobufValue for Event_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextAction {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    context: ::std::option::Option<u32>,
    action: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    pub actor: ::protobuf::SingularPtrField<User>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextAction {
    fn default() -> &'a ContextAction {
        <ContextAction as ::protobuf::Message>::default_instance()
    }
}

impl ContextAction {
    pub fn new() -> ContextAction {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 context = 2;


    pub fn get_context(&self) -> u32 {
        self.context.unwrap_or(0)
    }
    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    // optional string action = 3;


    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string text = 4;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .MurmurRPC.User actor = 5;


    pub fn get_actor(&self) -> &User {
        self.actor.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: User) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut User {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> User {
        self.actor.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.User user = 6;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.Channel channel = 7;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }
}

impl ::protobuf::Message for ContextAction {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.context = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.context {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.context {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextAction {
        ContextAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &ContextAction| { &m.server },
                |m: &mut ContextAction| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "context",
                |m: &ContextAction| { &m.context },
                |m: &mut ContextAction| { &mut m.context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &ContextAction| { &m.action },
                |m: &mut ContextAction| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &ContextAction| { &m.text },
                |m: &mut ContextAction| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "actor",
                |m: &ContextAction| { &m.actor },
                |m: &mut ContextAction| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &ContextAction| { &m.user },
                |m: &mut ContextAction| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &ContextAction| { &m.channel },
                |m: &mut ContextAction| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextAction>(
                "ContextAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextAction {
        static instance: ::protobuf::rt::LazyV2<ContextAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextAction::new)
    }
}

impl ::protobuf::Clear for ContextAction {
    fn clear(&mut self) {
        self.server.clear();
        self.context = ::std::option::Option::None;
        self.action.clear();
        self.text.clear();
        self.actor.clear();
        self.user.clear();
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContextAction_Context {
    Server = 1,
    Channel = 2,
    User = 4,
}

impl ::protobuf::ProtobufEnum for ContextAction_Context {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContextAction_Context> {
        match value {
            1 => ::std::option::Option::Some(ContextAction_Context::Server),
            2 => ::std::option::Option::Some(ContextAction_Context::Channel),
            4 => ::std::option::Option::Some(ContextAction_Context::User),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContextAction_Context] = &[
            ContextAction_Context::Server,
            ContextAction_Context::Channel,
            ContextAction_Context::User,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ContextAction_Context>("ContextAction.Context", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ContextAction_Context {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ContextAction_Context {
    fn default() -> Self {
        ContextAction_Context::Server
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextAction_Context {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextMessage {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub actor: ::protobuf::SingularPtrField<User>,
    pub users: ::protobuf::RepeatedField<User>,
    pub channels: ::protobuf::RepeatedField<Channel>,
    pub trees: ::protobuf::RepeatedField<Channel>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextMessage {
    fn default() -> &'a TextMessage {
        <TextMessage as ::protobuf::Message>::default_instance()
    }
}

impl TextMessage {
    pub fn new() -> TextMessage {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.User actor = 2;


    pub fn get_actor(&self) -> &User {
        self.actor.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: User) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut User {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> User {
        self.actor.take().unwrap_or_else(|| User::new())
    }

    // repeated .MurmurRPC.User users = 3;


    pub fn get_users(&self) -> &[User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.Channel channels = 4;


    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.Channel trees = 5;


    pub fn get_trees(&self) -> &[Channel] {
        &self.trees
    }
    pub fn clear_trees(&mut self) {
        self.trees.clear();
    }

    // Param is passed by value, moved
    pub fn set_trees(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.trees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trees(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.trees
    }

    // Take field
    pub fn take_trees(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.trees, ::protobuf::RepeatedField::new())
    }

    // optional string text = 6;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TextMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trees {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trees)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.trees {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.users {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.trees {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextMessage {
        TextMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &TextMessage| { &m.server },
                |m: &mut TextMessage| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "actor",
                |m: &TextMessage| { &m.actor },
                |m: &mut TextMessage| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "users",
                |m: &TextMessage| { &m.users },
                |m: &mut TextMessage| { &mut m.users },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channels",
                |m: &TextMessage| { &m.channels },
                |m: &mut TextMessage| { &mut m.channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "trees",
                |m: &TextMessage| { &m.trees },
                |m: &mut TextMessage| { &mut m.trees },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &TextMessage| { &m.text },
                |m: &mut TextMessage| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextMessage>(
                "TextMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextMessage {
        static instance: ::protobuf::rt::LazyV2<TextMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextMessage::new)
    }
}

impl ::protobuf::Clear for TextMessage {
    fn clear(&mut self) {
        self.server.clear();
        self.actor.clear();
        self.users.clear();
        self.channels.clear();
        self.trees.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextMessage_Filter {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    action: ::std::option::Option<TextMessage_Filter_Action>,
    pub message: ::protobuf::SingularPtrField<TextMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextMessage_Filter {
    fn default() -> &'a TextMessage_Filter {
        <TextMessage_Filter as ::protobuf::Message>::default_instance()
    }
}

impl TextMessage_Filter {
    pub fn new() -> TextMessage_Filter {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.TextMessage.Filter.Action action = 2;


    pub fn get_action(&self) -> TextMessage_Filter_Action {
        self.action.unwrap_or(TextMessage_Filter_Action::Accept)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: TextMessage_Filter_Action) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.TextMessage message = 3;


    pub fn get_message(&self) -> &TextMessage {
        self.message.as_ref().unwrap_or_else(|| <TextMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: TextMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut TextMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> TextMessage {
        self.message.take().unwrap_or_else(|| TextMessage::new())
    }
}

impl ::protobuf::Message for TextMessage_Filter {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.action {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextMessage_Filter {
        TextMessage_Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &TextMessage_Filter| { &m.server },
                |m: &mut TextMessage_Filter| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TextMessage_Filter_Action>>(
                "action",
                |m: &TextMessage_Filter| { &m.action },
                |m: &mut TextMessage_Filter| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextMessage>>(
                "message",
                |m: &TextMessage_Filter| { &m.message },
                |m: &mut TextMessage_Filter| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextMessage_Filter>(
                "TextMessage.Filter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextMessage_Filter {
        static instance: ::protobuf::rt::LazyV2<TextMessage_Filter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextMessage_Filter::new)
    }
}

impl ::protobuf::Clear for TextMessage_Filter {
    fn clear(&mut self) {
        self.server.clear();
        self.action = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextMessage_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage_Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TextMessage_Filter_Action {
    Accept = 0,
    Reject = 1,
    Drop = 2,
}

impl ::protobuf::ProtobufEnum for TextMessage_Filter_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TextMessage_Filter_Action> {
        match value {
            0 => ::std::option::Option::Some(TextMessage_Filter_Action::Accept),
            1 => ::std::option::Option::Some(TextMessage_Filter_Action::Reject),
            2 => ::std::option::Option::Some(TextMessage_Filter_Action::Drop),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TextMessage_Filter_Action] = &[
            TextMessage_Filter_Action::Accept,
            TextMessage_Filter_Action::Reject,
            TextMessage_Filter_Action::Drop,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TextMessage_Filter_Action>("TextMessage.Filter.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TextMessage_Filter_Action {
}

impl ::std::default::Default for TextMessage_Filter_Action {
    fn default() -> Self {
        TextMessage_Filter_Action::Accept
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage_Filter_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Log {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    timestamp: ::std::option::Option<i64>,
    text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log {
    fn default() -> &'a Log {
        <Log as ::protobuf::Message>::default_instance()
    }
}

impl Log {
    pub fn new() -> Log {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string text = 3;


    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Log {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log {
        Log::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Log| { &m.server },
                |m: &mut Log| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Log| { &m.timestamp },
                |m: &mut Log| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &Log| { &m.text },
                |m: &mut Log| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Log>(
                "Log",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Log {
        static instance: ::protobuf::rt::LazyV2<Log> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Log::new)
    }
}

impl ::protobuf::Clear for Log {
    fn clear(&mut self) {
        self.server.clear();
        self.timestamp = ::std::option::Option::None;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Log_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    min: ::std::option::Option<u32>,
    max: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log_Query {
    fn default() -> &'a Log_Query {
        <Log_Query as ::protobuf::Message>::default_instance()
    }
}

impl Log_Query {
    pub fn new() -> Log_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 min = 2;


    pub fn get_min(&self) -> u32 {
        self.min.unwrap_or(0)
    }
    pub fn clear_min(&mut self) {
        self.min = ::std::option::Option::None;
    }

    pub fn has_min(&self) -> bool {
        self.min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: u32) {
        self.min = ::std::option::Option::Some(v);
    }

    // optional uint32 max = 3;


    pub fn get_max(&self) -> u32 {
        self.max.unwrap_or(0)
    }
    pub fn clear_max(&mut self) {
        self.max = ::std::option::Option::None;
    }

    pub fn has_max(&self) -> bool {
        self.max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u32) {
        self.max = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Log_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.min {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.min {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log_Query {
        Log_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Log_Query| { &m.server },
                |m: &mut Log_Query| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "min",
                |m: &Log_Query| { &m.min },
                |m: &mut Log_Query| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max",
                |m: &Log_Query| { &m.max },
                |m: &mut Log_Query| { &mut m.max },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Log_Query>(
                "Log.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Log_Query {
        static instance: ::protobuf::rt::LazyV2<Log_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Log_Query::new)
    }
}

impl ::protobuf::Clear for Log_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.min = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Log_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Log_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    total: ::std::option::Option<u32>,
    min: ::std::option::Option<u32>,
    max: ::std::option::Option<u32>,
    pub entries: ::protobuf::RepeatedField<Log>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Log_List {
    fn default() -> &'a Log_List {
        <Log_List as ::protobuf::Message>::default_instance()
    }
}

impl Log_List {
    pub fn new() -> Log_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 total = 2;


    pub fn get_total(&self) -> u32 {
        self.total.unwrap_or(0)
    }
    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: u32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional uint32 min = 3;


    pub fn get_min(&self) -> u32 {
        self.min.unwrap_or(0)
    }
    pub fn clear_min(&mut self) {
        self.min = ::std::option::Option::None;
    }

    pub fn has_min(&self) -> bool {
        self.min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: u32) {
        self.min = ::std::option::Option::Some(v);
    }

    // optional uint32 max = 4;


    pub fn get_max(&self) -> u32 {
        self.max.unwrap_or(0)
    }
    pub fn clear_max(&mut self) {
        self.max = ::std::option::Option::None;
    }

    pub fn has_max(&self) -> bool {
        self.max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: u32) {
        self.max = ::std::option::Option::Some(v);
    }

    // repeated .MurmurRPC.Log entries = 5;


    pub fn get_entries(&self) -> &[Log] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<Log>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<Log> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<Log> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Log_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.min {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.total {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Log_List {
        Log_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Log_List| { &m.server },
                |m: &mut Log_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total",
                |m: &Log_List| { &m.total },
                |m: &mut Log_List| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "min",
                |m: &Log_List| { &m.min },
                |m: &mut Log_List| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max",
                |m: &Log_List| { &m.max },
                |m: &mut Log_List| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Log>>(
                "entries",
                |m: &Log_List| { &m.entries },
                |m: &mut Log_List| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Log_List>(
                "Log.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Log_List {
        static instance: ::protobuf::rt::LazyV2<Log_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Log_List::new)
    }
}

impl ::protobuf::Clear for Log_List {
    fn clear(&mut self) {
        self.server.clear();
        self.total = ::std::option::Option::None;
        self.min = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Log_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Log_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub fields: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // repeated .MurmurRPC.Config.FieldsEntry fields = 2;


    pub fn get_fields(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.fields
    }
    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.fields, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.fields);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.fields, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Config| { &m.server },
                |m: &mut Config| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "fields",
                |m: &Config| { &m.fields },
                |m: &mut Config| { &mut m.fields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config>(
                "Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.server.clear();
        self.fields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config_Field {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config_Field {
    fn default() -> &'a Config_Field {
        <Config_Field as ::protobuf::Message>::default_instance()
    }
}

impl Config_Field {
    pub fn new() -> Config_Field {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Config_Field {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config_Field {
        Config_Field::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Config_Field| { &m.server },
                |m: &mut Config_Field| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Config_Field| { &m.key },
                |m: &mut Config_Field| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Config_Field| { &m.value },
                |m: &mut Config_Field| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config_Field>(
                "Config.Field",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config_Field {
        static instance: ::protobuf::rt::LazyV2<Config_Field> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config_Field::new)
    }
}

impl ::protobuf::Clear for Config_Field {
    fn clear(&mut self) {
        self.server.clear();
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config_Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config_Field {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub parent: ::protobuf::SingularPtrField<Channel>,
    pub links: ::protobuf::RepeatedField<Channel>,
    description: ::protobuf::SingularField<::std::string::String>,
    temporary: ::std::option::Option<bool>,
    position: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel {
    fn default() -> &'a Channel {
        <Channel as ::protobuf::Message>::default_instance()
    }
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .MurmurRPC.Channel parent = 4;


    pub fn get_parent(&self) -> &Channel {
        self.parent.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: Channel) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut Channel {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> Channel {
        self.parent.take().unwrap_or_else(|| Channel::new())
    }

    // repeated .MurmurRPC.Channel links = 5;


    pub fn get_links(&self) -> &[Channel] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // optional string description = 6;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool temporary = 7;


    pub fn get_temporary(&self) -> bool {
        self.temporary.unwrap_or(false)
    }
    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }

    // optional int32 position = 8;


    pub fn get_position(&self) -> i32 {
        self.position.unwrap_or(0)
    }
    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.temporary = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.temporary {
            my_size += 2;
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.links {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.temporary {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.position {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Channel| { &m.server },
                |m: &mut Channel| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Channel| { &m.id },
                |m: &mut Channel| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Channel| { &m.name },
                |m: &mut Channel| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "parent",
                |m: &Channel| { &m.parent },
                |m: &mut Channel| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "links",
                |m: &Channel| { &m.links },
                |m: &mut Channel| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Channel| { &m.description },
                |m: &mut Channel| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "temporary",
                |m: &Channel| { &m.temporary },
                |m: &mut Channel| { &mut m.temporary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "position",
                |m: &Channel| { &m.position },
                |m: &mut Channel| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel>(
                "Channel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel {
        static instance: ::protobuf::rt::LazyV2<Channel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel::new)
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.server.clear();
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.parent.clear();
        self.links.clear();
        self.description.clear();
        self.temporary = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel_Query {
    fn default() -> &'a Channel_Query {
        <Channel_Query as ::protobuf::Message>::default_instance()
    }
}

impl Channel_Query {
    pub fn new() -> Channel_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }
}

impl ::protobuf::Message for Channel_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel_Query {
        Channel_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Channel_Query| { &m.server },
                |m: &mut Channel_Query| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel_Query>(
                "Channel.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel_Query {
        static instance: ::protobuf::rt::LazyV2<Channel_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel_Query::new)
    }
}

impl ::protobuf::Clear for Channel_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel_List {
    fn default() -> &'a Channel_List {
        <Channel_List as ::protobuf::Message>::default_instance()
    }
}

impl Channel_List {
    pub fn new() -> Channel_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // repeated .MurmurRPC.Channel channels = 2;


    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Channel_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel_List {
        Channel_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Channel_List| { &m.server },
                |m: &mut Channel_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channels",
                |m: &Channel_List| { &m.channels },
                |m: &mut Channel_List| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel_List>(
                "Channel.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel_List {
        static instance: ::protobuf::rt::LazyV2<Channel_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel_List::new)
    }
}

impl ::protobuf::Clear for Channel_List {
    fn clear(&mut self) {
        self.server.clear();
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    session: ::std::option::Option<u32>,
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    mute: ::std::option::Option<bool>,
    deaf: ::std::option::Option<bool>,
    suppress: ::std::option::Option<bool>,
    priority_speaker: ::std::option::Option<bool>,
    self_mute: ::std::option::Option<bool>,
    self_deaf: ::std::option::Option<bool>,
    recording: ::std::option::Option<bool>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    online_secs: ::std::option::Option<u32>,
    idle_secs: ::std::option::Option<u32>,
    bytes_per_sec: ::std::option::Option<u32>,
    pub version: ::protobuf::SingularPtrField<Version>,
    plugin_context: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    plugin_identity: ::protobuf::SingularField<::std::string::String>,
    comment: ::protobuf::SingularField<::std::string::String>,
    texture: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tcp_only: ::std::option::Option<bool>,
    udp_ping_msecs: ::std::option::Option<f32>,
    tcp_ping_msecs: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 session = 2;


    pub fn get_session(&self) -> u32 {
        self.session.unwrap_or(0)
    }
    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    // optional uint32 id = 3;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 4;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool mute = 5;


    pub fn get_mute(&self) -> bool {
        self.mute.unwrap_or(false)
    }
    pub fn clear_mute(&mut self) {
        self.mute = ::std::option::Option::None;
    }

    pub fn has_mute(&self) -> bool {
        self.mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute(&mut self, v: bool) {
        self.mute = ::std::option::Option::Some(v);
    }

    // optional bool deaf = 6;


    pub fn get_deaf(&self) -> bool {
        self.deaf.unwrap_or(false)
    }
    pub fn clear_deaf(&mut self) {
        self.deaf = ::std::option::Option::None;
    }

    pub fn has_deaf(&self) -> bool {
        self.deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaf(&mut self, v: bool) {
        self.deaf = ::std::option::Option::Some(v);
    }

    // optional bool suppress = 7;


    pub fn get_suppress(&self) -> bool {
        self.suppress.unwrap_or(false)
    }
    pub fn clear_suppress(&mut self) {
        self.suppress = ::std::option::Option::None;
    }

    pub fn has_suppress(&self) -> bool {
        self.suppress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress(&mut self, v: bool) {
        self.suppress = ::std::option::Option::Some(v);
    }

    // optional bool priority_speaker = 8;


    pub fn get_priority_speaker(&self) -> bool {
        self.priority_speaker.unwrap_or(false)
    }
    pub fn clear_priority_speaker(&mut self) {
        self.priority_speaker = ::std::option::Option::None;
    }

    pub fn has_priority_speaker(&self) -> bool {
        self.priority_speaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_speaker(&mut self, v: bool) {
        self.priority_speaker = ::std::option::Option::Some(v);
    }

    // optional bool self_mute = 9;


    pub fn get_self_mute(&self) -> bool {
        self.self_mute.unwrap_or(false)
    }
    pub fn clear_self_mute(&mut self) {
        self.self_mute = ::std::option::Option::None;
    }

    pub fn has_self_mute(&self) -> bool {
        self.self_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_mute(&mut self, v: bool) {
        self.self_mute = ::std::option::Option::Some(v);
    }

    // optional bool self_deaf = 10;


    pub fn get_self_deaf(&self) -> bool {
        self.self_deaf.unwrap_or(false)
    }
    pub fn clear_self_deaf(&mut self) {
        self.self_deaf = ::std::option::Option::None;
    }

    pub fn has_self_deaf(&self) -> bool {
        self.self_deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_deaf(&mut self, v: bool) {
        self.self_deaf = ::std::option::Option::Some(v);
    }

    // optional bool recording = 11;


    pub fn get_recording(&self) -> bool {
        self.recording.unwrap_or(false)
    }
    pub fn clear_recording(&mut self) {
        self.recording = ::std::option::Option::None;
    }

    pub fn has_recording(&self) -> bool {
        self.recording.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording(&mut self, v: bool) {
        self.recording = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.Channel channel = 12;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }

    // optional uint32 online_secs = 13;


    pub fn get_online_secs(&self) -> u32 {
        self.online_secs.unwrap_or(0)
    }
    pub fn clear_online_secs(&mut self) {
        self.online_secs = ::std::option::Option::None;
    }

    pub fn has_online_secs(&self) -> bool {
        self.online_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_secs(&mut self, v: u32) {
        self.online_secs = ::std::option::Option::Some(v);
    }

    // optional uint32 idle_secs = 14;


    pub fn get_idle_secs(&self) -> u32 {
        self.idle_secs.unwrap_or(0)
    }
    pub fn clear_idle_secs(&mut self) {
        self.idle_secs = ::std::option::Option::None;
    }

    pub fn has_idle_secs(&self) -> bool {
        self.idle_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_secs(&mut self, v: u32) {
        self.idle_secs = ::std::option::Option::Some(v);
    }

    // optional uint32 bytes_per_sec = 15;


    pub fn get_bytes_per_sec(&self) -> u32 {
        self.bytes_per_sec.unwrap_or(0)
    }
    pub fn clear_bytes_per_sec(&mut self) {
        self.bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_bytes_per_sec(&self) -> bool {
        self.bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_per_sec(&mut self, v: u32) {
        self.bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.Version version = 16;


    pub fn get_version(&self) -> &Version {
        self.version.as_ref().unwrap_or_else(|| <Version as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: Version) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut Version {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> Version {
        self.version.take().unwrap_or_else(|| Version::new())
    }

    // optional bytes plugin_context = 17;


    pub fn get_plugin_context(&self) -> &[u8] {
        match self.plugin_context.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_plugin_context(&mut self) {
        self.plugin_context.clear();
    }

    pub fn has_plugin_context(&self) -> bool {
        self.plugin_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.plugin_context = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_context(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.plugin_context.is_none() {
            self.plugin_context.set_default();
        }
        self.plugin_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_context(&mut self) -> ::std::vec::Vec<u8> {
        self.plugin_context.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string plugin_identity = 18;


    pub fn get_plugin_identity(&self) -> &str {
        match self.plugin_identity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_plugin_identity(&mut self) {
        self.plugin_identity.clear();
    }

    pub fn has_plugin_identity(&self) -> bool {
        self.plugin_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_identity(&mut self, v: ::std::string::String) {
        self.plugin_identity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_identity(&mut self) -> &mut ::std::string::String {
        if self.plugin_identity.is_none() {
            self.plugin_identity.set_default();
        }
        self.plugin_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_identity(&mut self) -> ::std::string::String {
        self.plugin_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string comment = 19;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes texture = 20;


    pub fn get_texture(&self) -> &[u8] {
        match self.texture.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_texture(&mut self) {
        self.texture.clear();
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture.is_none() {
            self.texture.set_default();
        }
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> ::std::vec::Vec<u8> {
        self.texture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes address = 21;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool tcp_only = 22;


    pub fn get_tcp_only(&self) -> bool {
        self.tcp_only.unwrap_or(false)
    }
    pub fn clear_tcp_only(&mut self) {
        self.tcp_only = ::std::option::Option::None;
    }

    pub fn has_tcp_only(&self) -> bool {
        self.tcp_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_only(&mut self, v: bool) {
        self.tcp_only = ::std::option::Option::Some(v);
    }

    // optional float udp_ping_msecs = 23;


    pub fn get_udp_ping_msecs(&self) -> f32 {
        self.udp_ping_msecs.unwrap_or(0.)
    }
    pub fn clear_udp_ping_msecs(&mut self) {
        self.udp_ping_msecs = ::std::option::Option::None;
    }

    pub fn has_udp_ping_msecs(&self) -> bool {
        self.udp_ping_msecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_msecs(&mut self, v: f32) {
        self.udp_ping_msecs = ::std::option::Option::Some(v);
    }

    // optional float tcp_ping_msecs = 24;


    pub fn get_tcp_ping_msecs(&self) -> f32 {
        self.tcp_ping_msecs.unwrap_or(0.)
    }
    pub fn clear_tcp_ping_msecs(&mut self) {
        self.tcp_ping_msecs = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_msecs(&self) -> bool {
        self.tcp_ping_msecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_msecs(&mut self, v: f32) {
        self.tcp_ping_msecs = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.session = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mute = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deaf = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppress = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.priority_speaker = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.self_mute = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.self_deaf = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recording = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.online_secs = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.idle_secs = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytes_per_sec = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.plugin_context)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.plugin_identity)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tcp_only = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.udp_ping_msecs = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tcp_ping_msecs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.session {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.mute {
            my_size += 2;
        }
        if let Some(v) = self.deaf {
            my_size += 2;
        }
        if let Some(v) = self.suppress {
            my_size += 2;
        }
        if let Some(v) = self.priority_speaker {
            my_size += 2;
        }
        if let Some(v) = self.self_mute {
            my_size += 2;
        }
        if let Some(v) = self.self_deaf {
            my_size += 2;
        }
        if let Some(v) = self.recording {
            my_size += 2;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.online_secs {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.idle_secs {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes_per_sec {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.plugin_context.as_ref() {
            my_size += ::protobuf::rt::bytes_size(17, &v);
        }
        if let Some(ref v) = self.plugin_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(ref v) = self.texture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.tcp_only {
            my_size += 3;
        }
        if let Some(v) = self.udp_ping_msecs {
            my_size += 6;
        }
        if let Some(v) = self.tcp_ping_msecs {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.session {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.mute {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.deaf {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.suppress {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.priority_speaker {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.self_mute {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.self_deaf {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.recording {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.online_secs {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.idle_secs {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.bytes_per_sec {
            os.write_uint32(15, v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.plugin_context.as_ref() {
            os.write_bytes(17, &v)?;
        }
        if let Some(ref v) = self.plugin_identity.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(19, &v)?;
        }
        if let Some(ref v) = self.texture.as_ref() {
            os.write_bytes(20, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(21, &v)?;
        }
        if let Some(v) = self.tcp_only {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.udp_ping_msecs {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.tcp_ping_msecs {
            os.write_float(24, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &User| { &m.server },
                |m: &mut User| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "session",
                |m: &User| { &m.session },
                |m: &mut User| { &mut m.session },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &User| { &m.id },
                |m: &mut User| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &User| { &m.name },
                |m: &mut User| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mute",
                |m: &User| { &m.mute },
                |m: &mut User| { &mut m.mute },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deaf",
                |m: &User| { &m.deaf },
                |m: &mut User| { &mut m.deaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "suppress",
                |m: &User| { &m.suppress },
                |m: &mut User| { &mut m.suppress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "priority_speaker",
                |m: &User| { &m.priority_speaker },
                |m: &mut User| { &mut m.priority_speaker },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "self_mute",
                |m: &User| { &m.self_mute },
                |m: &mut User| { &mut m.self_mute },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "self_deaf",
                |m: &User| { &m.self_deaf },
                |m: &mut User| { &mut m.self_deaf },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recording",
                |m: &User| { &m.recording },
                |m: &mut User| { &mut m.recording },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &User| { &m.channel },
                |m: &mut User| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "online_secs",
                |m: &User| { &m.online_secs },
                |m: &mut User| { &mut m.online_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "idle_secs",
                |m: &User| { &m.idle_secs },
                |m: &mut User| { &mut m.idle_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytes_per_sec",
                |m: &User| { &m.bytes_per_sec },
                |m: &mut User| { &mut m.bytes_per_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Version>>(
                "version",
                |m: &User| { &m.version },
                |m: &mut User| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "plugin_context",
                |m: &User| { &m.plugin_context },
                |m: &mut User| { &mut m.plugin_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plugin_identity",
                |m: &User| { &m.plugin_identity },
                |m: &mut User| { &mut m.plugin_identity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &User| { &m.comment },
                |m: &mut User| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "texture",
                |m: &User| { &m.texture },
                |m: &mut User| { &mut m.texture },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &User| { &m.address },
                |m: &mut User| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tcp_only",
                |m: &User| { &m.tcp_only },
                |m: &mut User| { &mut m.tcp_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "udp_ping_msecs",
                |m: &User| { &m.udp_ping_msecs },
                |m: &mut User| { &mut m.udp_ping_msecs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tcp_ping_msecs",
                |m: &User| { &m.tcp_ping_msecs },
                |m: &mut User| { &mut m.tcp_ping_msecs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User>(
                "User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User {
        static instance: ::protobuf::rt::LazyV2<User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User::new)
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.server.clear();
        self.session = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.mute = ::std::option::Option::None;
        self.deaf = ::std::option::Option::None;
        self.suppress = ::std::option::Option::None;
        self.priority_speaker = ::std::option::Option::None;
        self.self_mute = ::std::option::Option::None;
        self.self_deaf = ::std::option::Option::None;
        self.recording = ::std::option::Option::None;
        self.channel.clear();
        self.online_secs = ::std::option::Option::None;
        self.idle_secs = ::std::option::Option::None;
        self.bytes_per_sec = ::std::option::Option::None;
        self.version.clear();
        self.plugin_context.clear();
        self.plugin_identity.clear();
        self.comment.clear();
        self.texture.clear();
        self.address.clear();
        self.tcp_only = ::std::option::Option::None;
        self.udp_ping_msecs = ::std::option::Option::None;
        self.tcp_ping_msecs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User_Query {
    fn default() -> &'a User_Query {
        <User_Query as ::protobuf::Message>::default_instance()
    }
}

impl User_Query {
    pub fn new() -> User_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }
}

impl ::protobuf::Message for User_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User_Query {
        User_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &User_Query| { &m.server },
                |m: &mut User_Query| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User_Query>(
                "User.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User_Query {
        static instance: ::protobuf::rt::LazyV2<User_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User_Query::new)
    }
}

impl ::protobuf::Clear for User_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub users: ::protobuf::RepeatedField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User_List {
    fn default() -> &'a User_List {
        <User_List as ::protobuf::Message>::default_instance()
    }
}

impl User_List {
    pub fn new() -> User_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // repeated .MurmurRPC.User users = 2;


    pub fn get_users(&self) -> &[User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for User_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.users {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User_List {
        User_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &User_List| { &m.server },
                |m: &mut User_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "users",
                |m: &User_List| { &m.users },
                |m: &mut User_List| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User_List>(
                "User.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User_List {
        static instance: ::protobuf::rt::LazyV2<User_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User_List::new)
    }
}

impl ::protobuf::Clear for User_List {
    fn clear(&mut self) {
        self.server.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User_Kick {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub actor: ::protobuf::SingularPtrField<User>,
    reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User_Kick {
    fn default() -> &'a User_Kick {
        <User_Kick as ::protobuf::Message>::default_instance()
    }
}

impl User_Kick {
    pub fn new() -> User_Kick {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.User user = 2;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.User actor = 3;


    pub fn get_actor(&self) -> &User {
        self.actor.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: User) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut User {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> User {
        self.actor.take().unwrap_or_else(|| User::new())
    }

    // optional string reason = 4;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for User_Kick {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User_Kick {
        User_Kick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &User_Kick| { &m.server },
                |m: &mut User_Kick| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &User_Kick| { &m.user },
                |m: &mut User_Kick| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "actor",
                |m: &User_Kick| { &m.actor },
                |m: &mut User_Kick| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &User_Kick| { &m.reason },
                |m: &mut User_Kick| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User_Kick>(
                "User.Kick",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User_Kick {
        static instance: ::protobuf::rt::LazyV2<User_Kick> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User_Kick::new)
    }
}

impl ::protobuf::Clear for User_Kick {
    fn clear(&mut self) {
        self.server.clear();
        self.user.clear();
        self.actor.clear();
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User_Kick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User_Kick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tree {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    pub children: ::protobuf::RepeatedField<Tree>,
    pub users: ::protobuf::RepeatedField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tree {
    fn default() -> &'a Tree {
        <Tree as ::protobuf::Message>::default_instance()
    }
}

impl Tree {
    pub fn new() -> Tree {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.Channel channel = 2;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }

    // repeated .MurmurRPC.Tree children = 3;


    pub fn get_children(&self) -> &[Tree] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<Tree>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<Tree> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<Tree> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.User users = 4;


    pub fn get_users(&self) -> &[User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tree {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.children {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.users {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tree {
        Tree::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Tree| { &m.server },
                |m: &mut Tree| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &Tree| { &m.channel },
                |m: &mut Tree| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tree>>(
                "children",
                |m: &Tree| { &m.children },
                |m: &mut Tree| { &mut m.children },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "users",
                |m: &Tree| { &m.users },
                |m: &mut Tree| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tree>(
                "Tree",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tree {
        static instance: ::protobuf::rt::LazyV2<Tree> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tree::new)
    }
}

impl ::protobuf::Clear for Tree {
    fn clear(&mut self) {
        self.server.clear();
        self.channel.clear();
        self.children.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tree {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tree_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tree_Query {
    fn default() -> &'a Tree_Query {
        <Tree_Query as ::protobuf::Message>::default_instance()
    }
}

impl Tree_Query {
    pub fn new() -> Tree_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }
}

impl ::protobuf::Message for Tree_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tree_Query {
        Tree_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Tree_Query| { &m.server },
                |m: &mut Tree_Query| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tree_Query>(
                "Tree.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tree_Query {
        static instance: ::protobuf::rt::LazyV2<Tree_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tree_Query::new)
    }
}

impl ::protobuf::Clear for Tree_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tree_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tree_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ban {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bits: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    start: ::std::option::Option<i64>,
    duration_secs: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ban {
    fn default() -> &'a Ban {
        <Ban as ::protobuf::Message>::default_instance()
    }
}

impl Ban {
    pub fn new() -> Ban {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 bits = 3;


    pub fn get_bits(&self) -> u32 {
        self.bits.unwrap_or(0)
    }
    pub fn clear_bits(&mut self) {
        self.bits = ::std::option::Option::None;
    }

    pub fn has_bits(&self) -> bool {
        self.bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u32) {
        self.bits = ::std::option::Option::Some(v);
    }

    // optional string name = 4;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hash = 5;


    pub fn get_hash(&self) -> &str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 6;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 start = 7;


    pub fn get_start(&self) -> i64 {
        self.start.unwrap_or(0)
    }
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i64) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int64 duration_secs = 8;


    pub fn get_duration_secs(&self) -> i64 {
        self.duration_secs.unwrap_or(0)
    }
    pub fn clear_duration_secs(&mut self) {
        self.duration_secs = ::std::option::Option::None;
    }

    pub fn has_duration_secs(&self) -> bool {
        self.duration_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_secs(&mut self, v: i64) {
        self.duration_secs = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Ban {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.duration_secs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.bits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duration_secs {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.bits {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.start {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.duration_secs {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ban {
        Ban::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Ban| { &m.server },
                |m: &mut Ban| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &Ban| { &m.address },
                |m: &mut Ban| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bits",
                |m: &Ban| { &m.bits },
                |m: &mut Ban| { &mut m.bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Ban| { &m.name },
                |m: &mut Ban| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &Ban| { &m.hash },
                |m: &mut Ban| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &Ban| { &m.reason },
                |m: &mut Ban| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start",
                |m: &Ban| { &m.start },
                |m: &mut Ban| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "duration_secs",
                |m: &Ban| { &m.duration_secs },
                |m: &mut Ban| { &mut m.duration_secs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ban>(
                "Ban",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ban {
        static instance: ::protobuf::rt::LazyV2<Ban> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ban::new)
    }
}

impl ::protobuf::Clear for Ban {
    fn clear(&mut self) {
        self.server.clear();
        self.address.clear();
        self.bits = ::std::option::Option::None;
        self.name.clear();
        self.hash.clear();
        self.reason.clear();
        self.start = ::std::option::Option::None;
        self.duration_secs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ban {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ban {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ban_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ban_Query {
    fn default() -> &'a Ban_Query {
        <Ban_Query as ::protobuf::Message>::default_instance()
    }
}

impl Ban_Query {
    pub fn new() -> Ban_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }
}

impl ::protobuf::Message for Ban_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ban_Query {
        Ban_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Ban_Query| { &m.server },
                |m: &mut Ban_Query| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ban_Query>(
                "Ban.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ban_Query {
        static instance: ::protobuf::rt::LazyV2<Ban_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ban_Query::new)
    }
}

impl ::protobuf::Clear for Ban_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ban_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ban_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ban_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub bans: ::protobuf::RepeatedField<Ban>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Ban_List {
    fn default() -> &'a Ban_List {
        <Ban_List as ::protobuf::Message>::default_instance()
    }
}

impl Ban_List {
    pub fn new() -> Ban_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // repeated .MurmurRPC.Ban bans = 2;


    pub fn get_bans(&self) -> &[Ban] {
        &self.bans
    }
    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<Ban>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::protobuf::RepeatedField<Ban> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<Ban> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Ban_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bans {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ban_List {
        Ban_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Ban_List| { &m.server },
                |m: &mut Ban_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ban>>(
                "bans",
                |m: &Ban_List| { &m.bans },
                |m: &mut Ban_List| { &mut m.bans },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Ban_List>(
                "Ban.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Ban_List {
        static instance: ::protobuf::rt::LazyV2<Ban_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Ban_List::new)
    }
}

impl ::protobuf::Clear for Ban_List {
    fn clear(&mut self) {
        self.server.clear();
        self.bans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ban_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ban_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL {
    // message fields
    apply_here: ::std::option::Option<bool>,
    apply_subs: ::std::option::Option<bool>,
    inherited: ::std::option::Option<bool>,
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    pub group: ::protobuf::SingularPtrField<ACL_Group>,
    allow: ::std::option::Option<u32>,
    deny: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL {
    fn default() -> &'a ACL {
        <ACL as ::protobuf::Message>::default_instance()
    }
}

impl ACL {
    pub fn new() -> ACL {
        ::std::default::Default::default()
    }

    // optional bool apply_here = 3;


    pub fn get_apply_here(&self) -> bool {
        self.apply_here.unwrap_or(false)
    }
    pub fn clear_apply_here(&mut self) {
        self.apply_here = ::std::option::Option::None;
    }

    pub fn has_apply_here(&self) -> bool {
        self.apply_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_here(&mut self, v: bool) {
        self.apply_here = ::std::option::Option::Some(v);
    }

    // optional bool apply_subs = 4;


    pub fn get_apply_subs(&self) -> bool {
        self.apply_subs.unwrap_or(false)
    }
    pub fn clear_apply_subs(&mut self) {
        self.apply_subs = ::std::option::Option::None;
    }

    pub fn has_apply_subs(&self) -> bool {
        self.apply_subs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_subs(&mut self, v: bool) {
        self.apply_subs = ::std::option::Option::Some(v);
    }

    // optional bool inherited = 5;


    pub fn get_inherited(&self) -> bool {
        self.inherited.unwrap_or(false)
    }
    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.DatabaseUser user = 6;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }

    // optional .MurmurRPC.ACL.Group group = 7;


    pub fn get_group(&self) -> &ACL_Group {
        self.group.as_ref().unwrap_or_else(|| <ACL_Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ACL_Group) {
        self.group = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ACL_Group {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ACL_Group {
        self.group.take().unwrap_or_else(|| ACL_Group::new())
    }

    // optional uint32 allow = 8;


    pub fn get_allow(&self) -> u32 {
        self.allow.unwrap_or(0)
    }
    pub fn clear_allow(&mut self) {
        self.allow = ::std::option::Option::None;
    }

    pub fn has_allow(&self) -> bool {
        self.allow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow(&mut self, v: u32) {
        self.allow = ::std::option::Option::Some(v);
    }

    // optional uint32 deny = 9;


    pub fn get_deny(&self) -> u32 {
        self.deny.unwrap_or(0)
    }
    pub fn clear_deny(&mut self) {
        self.deny = ::std::option::Option::None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: u32) {
        self.deny = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ACL {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.apply_here = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.apply_subs = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.allow = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deny = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.apply_here {
            my_size += 2;
        }
        if let Some(v) = self.apply_subs {
            my_size += 2;
        }
        if let Some(v) = self.inherited {
            my_size += 2;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allow {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deny {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.apply_here {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.apply_subs {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.inherited {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.allow {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.deny {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL {
        ACL::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "apply_here",
                |m: &ACL| { &m.apply_here },
                |m: &mut ACL| { &mut m.apply_here },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "apply_subs",
                |m: &ACL| { &m.apply_subs },
                |m: &mut ACL| { &mut m.apply_subs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherited",
                |m: &ACL| { &m.inherited },
                |m: &mut ACL| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &ACL| { &m.user },
                |m: &mut ACL| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_Group>>(
                "group",
                |m: &ACL| { &m.group },
                |m: &mut ACL| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "allow",
                |m: &ACL| { &m.allow },
                |m: &mut ACL| { &mut m.allow },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deny",
                |m: &ACL| { &m.deny },
                |m: &mut ACL| { &mut m.deny },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL>(
                "ACL",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL {
        static instance: ::protobuf::rt::LazyV2<ACL> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL::new)
    }
}

impl ::protobuf::Clear for ACL {
    fn clear(&mut self) {
        self.apply_here = ::std::option::Option::None;
        self.apply_subs = ::std::option::Option::None;
        self.inherited = ::std::option::Option::None;
        self.user.clear();
        self.group.clear();
        self.allow = ::std::option::Option::None;
        self.deny = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_Group {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    inherited: ::std::option::Option<bool>,
    inherit: ::std::option::Option<bool>,
    inheritable: ::std::option::Option<bool>,
    pub users_add: ::protobuf::RepeatedField<DatabaseUser>,
    pub users_remove: ::protobuf::RepeatedField<DatabaseUser>,
    pub users: ::protobuf::RepeatedField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_Group {
    fn default() -> &'a ACL_Group {
        <ACL_Group as ::protobuf::Message>::default_instance()
    }
}

impl ACL_Group {
    pub fn new() -> ACL_Group {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inherited = 2;


    pub fn get_inherited(&self) -> bool {
        self.inherited.unwrap_or(false)
    }
    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    // optional bool inherit = 3;


    pub fn get_inherit(&self) -> bool {
        self.inherit.unwrap_or(false)
    }
    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    // optional bool inheritable = 4;


    pub fn get_inheritable(&self) -> bool {
        self.inheritable.unwrap_or(false)
    }
    pub fn clear_inheritable(&mut self) {
        self.inheritable = ::std::option::Option::None;
    }

    pub fn has_inheritable(&self) -> bool {
        self.inheritable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inheritable(&mut self, v: bool) {
        self.inheritable = ::std::option::Option::Some(v);
    }

    // repeated .MurmurRPC.DatabaseUser users_add = 5;


    pub fn get_users_add(&self) -> &[DatabaseUser] {
        &self.users_add
    }
    pub fn clear_users_add(&mut self) {
        self.users_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_users_add(&mut self, v: ::protobuf::RepeatedField<DatabaseUser>) {
        self.users_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users_add(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseUser> {
        &mut self.users_add
    }

    // Take field
    pub fn take_users_add(&mut self) -> ::protobuf::RepeatedField<DatabaseUser> {
        ::std::mem::replace(&mut self.users_add, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.DatabaseUser users_remove = 6;


    pub fn get_users_remove(&self) -> &[DatabaseUser] {
        &self.users_remove
    }
    pub fn clear_users_remove(&mut self) {
        self.users_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_users_remove(&mut self, v: ::protobuf::RepeatedField<DatabaseUser>) {
        self.users_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users_remove(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseUser> {
        &mut self.users_remove
    }

    // Take field
    pub fn take_users_remove(&mut self) -> ::protobuf::RepeatedField<DatabaseUser> {
        ::std::mem::replace(&mut self.users_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.DatabaseUser users = 7;


    pub fn get_users(&self) -> &[DatabaseUser] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<DatabaseUser>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseUser> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<DatabaseUser> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ACL_Group {
    fn is_initialized(&self) -> bool {
        for v in &self.users_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users_remove {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inheritable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users_add)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users_remove)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inherited {
            my_size += 2;
        }
        if let Some(v) = self.inherit {
            my_size += 2;
        }
        if let Some(v) = self.inheritable {
            my_size += 2;
        }
        for value in &self.users_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.users_remove {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.inherited {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.inherit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.inheritable {
            os.write_bool(4, v)?;
        }
        for v in &self.users_add {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.users_remove {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.users {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_Group {
        ACL_Group::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ACL_Group| { &m.name },
                |m: &mut ACL_Group| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherited",
                |m: &ACL_Group| { &m.inherited },
                |m: &mut ACL_Group| { &mut m.inherited },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit",
                |m: &ACL_Group| { &m.inherit },
                |m: &mut ACL_Group| { &mut m.inherit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inheritable",
                |m: &ACL_Group| { &m.inheritable },
                |m: &mut ACL_Group| { &mut m.inheritable },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "users_add",
                |m: &ACL_Group| { &m.users_add },
                |m: &mut ACL_Group| { &mut m.users_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "users_remove",
                |m: &ACL_Group| { &m.users_remove },
                |m: &mut ACL_Group| { &mut m.users_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "users",
                |m: &ACL_Group| { &m.users },
                |m: &mut ACL_Group| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_Group>(
                "ACL.Group",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_Group {
        static instance: ::protobuf::rt::LazyV2<ACL_Group> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_Group::new)
    }
}

impl ::protobuf::Clear for ACL_Group {
    fn clear(&mut self) {
        self.name.clear();
        self.inherited = ::std::option::Option::None;
        self.inherit = ::std::option::Option::None;
        self.inheritable = ::std::option::Option::None;
        self.users_add.clear();
        self.users_remove.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_Group {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_Group {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_Query {
    fn default() -> &'a ACL_Query {
        <ACL_Query as ::protobuf::Message>::default_instance()
    }
}

impl ACL_Query {
    pub fn new() -> ACL_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.User user = 2;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.Channel channel = 3;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }
}

impl ::protobuf::Message for ACL_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_Query {
        ACL_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &ACL_Query| { &m.server },
                |m: &mut ACL_Query| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &ACL_Query| { &m.user },
                |m: &mut ACL_Query| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &ACL_Query| { &m.channel },
                |m: &mut ACL_Query| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_Query>(
                "ACL.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_Query {
        static instance: ::protobuf::rt::LazyV2<ACL_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_Query::new)
    }
}

impl ::protobuf::Clear for ACL_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.user.clear();
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    pub acls: ::protobuf::RepeatedField<ACL>,
    pub groups: ::protobuf::RepeatedField<ACL_Group>,
    inherit: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_List {
    fn default() -> &'a ACL_List {
        <ACL_List as ::protobuf::Message>::default_instance()
    }
}

impl ACL_List {
    pub fn new() -> ACL_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.Channel channel = 2;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }

    // repeated .MurmurRPC.ACL acls = 3;


    pub fn get_acls(&self) -> &[ACL] {
        &self.acls
    }
    pub fn clear_acls(&mut self) {
        self.acls.clear();
    }

    // Param is passed by value, moved
    pub fn set_acls(&mut self, v: ::protobuf::RepeatedField<ACL>) {
        self.acls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acls(&mut self) -> &mut ::protobuf::RepeatedField<ACL> {
        &mut self.acls
    }

    // Take field
    pub fn take_acls(&mut self) -> ::protobuf::RepeatedField<ACL> {
        ::std::mem::replace(&mut self.acls, ::protobuf::RepeatedField::new())
    }

    // repeated .MurmurRPC.ACL.Group groups = 4;


    pub fn get_groups(&self) -> &[ACL_Group] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ACL_Group>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<ACL_Group> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ACL_Group> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    // optional bool inherit = 5;


    pub fn get_inherit(&self) -> bool {
        self.inherit.unwrap_or(false)
    }
    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ACL_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acls)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.acls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.inherit {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.acls {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.groups {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.inherit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_List {
        ACL_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &ACL_List| { &m.server },
                |m: &mut ACL_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &ACL_List| { &m.channel },
                |m: &mut ACL_List| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL>>(
                "acls",
                |m: &ACL_List| { &m.acls },
                |m: &mut ACL_List| { &mut m.acls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_Group>>(
                "groups",
                |m: &ACL_List| { &m.groups },
                |m: &mut ACL_List| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit",
                |m: &ACL_List| { &m.inherit },
                |m: &mut ACL_List| { &mut m.inherit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_List>(
                "ACL.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_List {
        static instance: ::protobuf::rt::LazyV2<ACL_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_List::new)
    }
}

impl ::protobuf::Clear for ACL_List {
    fn clear(&mut self) {
        self.server.clear();
        self.channel.clear();
        self.acls.clear();
        self.groups.clear();
        self.inherit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ACL_TemporaryGroup {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub channel: ::protobuf::SingularPtrField<Channel>,
    pub user: ::protobuf::SingularPtrField<User>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ACL_TemporaryGroup {
    fn default() -> &'a ACL_TemporaryGroup {
        <ACL_TemporaryGroup as ::protobuf::Message>::default_instance()
    }
}

impl ACL_TemporaryGroup {
    pub fn new() -> ACL_TemporaryGroup {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.Channel channel = 2;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }

    // optional .MurmurRPC.User user = 3;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional string name = 4;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ACL_TemporaryGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ACL_TemporaryGroup {
        ACL_TemporaryGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &ACL_TemporaryGroup| { &m.server },
                |m: &mut ACL_TemporaryGroup| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &ACL_TemporaryGroup| { &m.channel },
                |m: &mut ACL_TemporaryGroup| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &ACL_TemporaryGroup| { &m.user },
                |m: &mut ACL_TemporaryGroup| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ACL_TemporaryGroup| { &m.name },
                |m: &mut ACL_TemporaryGroup| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ACL_TemporaryGroup>(
                "ACL.TemporaryGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ACL_TemporaryGroup {
        static instance: ::protobuf::rt::LazyV2<ACL_TemporaryGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ACL_TemporaryGroup::new)
    }
}

impl ::protobuf::Clear for ACL_TemporaryGroup {
    fn clear(&mut self) {
        self.server.clear();
        self.channel.clear();
        self.user.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ACL_TemporaryGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_TemporaryGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ACL_Permission {
    None = 0,
    Write = 1,
    Traverse = 2,
    Enter = 4,
    Speak = 8,
    Whisper = 256,
    MuteDeafen = 16,
    Move = 32,
    MakeChannel = 64,
    MakeTemporaryChannel = 1024,
    LinkChannel = 128,
    TextMessage = 512,
    Kick = 65536,
    Ban = 131072,
    Register = 262144,
    RegisterSelf = 524288,
}

impl ::protobuf::ProtobufEnum for ACL_Permission {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ACL_Permission> {
        match value {
            0 => ::std::option::Option::Some(ACL_Permission::None),
            1 => ::std::option::Option::Some(ACL_Permission::Write),
            2 => ::std::option::Option::Some(ACL_Permission::Traverse),
            4 => ::std::option::Option::Some(ACL_Permission::Enter),
            8 => ::std::option::Option::Some(ACL_Permission::Speak),
            256 => ::std::option::Option::Some(ACL_Permission::Whisper),
            16 => ::std::option::Option::Some(ACL_Permission::MuteDeafen),
            32 => ::std::option::Option::Some(ACL_Permission::Move),
            64 => ::std::option::Option::Some(ACL_Permission::MakeChannel),
            1024 => ::std::option::Option::Some(ACL_Permission::MakeTemporaryChannel),
            128 => ::std::option::Option::Some(ACL_Permission::LinkChannel),
            512 => ::std::option::Option::Some(ACL_Permission::TextMessage),
            65536 => ::std::option::Option::Some(ACL_Permission::Kick),
            131072 => ::std::option::Option::Some(ACL_Permission::Ban),
            262144 => ::std::option::Option::Some(ACL_Permission::Register),
            524288 => ::std::option::Option::Some(ACL_Permission::RegisterSelf),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ACL_Permission] = &[
            ACL_Permission::None,
            ACL_Permission::Write,
            ACL_Permission::Traverse,
            ACL_Permission::Enter,
            ACL_Permission::Speak,
            ACL_Permission::Whisper,
            ACL_Permission::MuteDeafen,
            ACL_Permission::Move,
            ACL_Permission::MakeChannel,
            ACL_Permission::MakeTemporaryChannel,
            ACL_Permission::LinkChannel,
            ACL_Permission::TextMessage,
            ACL_Permission::Kick,
            ACL_Permission::Ban,
            ACL_Permission::Register,
            ACL_Permission::RegisterSelf,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ACL_Permission>("ACL.Permission", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ACL_Permission {
}

impl ::std::default::Default for ACL_Permission {
    fn default() -> Self {
        ACL_Permission::None
    }
}

impl ::protobuf::reflect::ProtobufValue for ACL_Permission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator {
    fn default() -> &'a Authenticator {
        <Authenticator as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator {
    pub fn new() -> Authenticator {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Authenticator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator {
        Authenticator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator>(
                "Authenticator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator {
        static instance: ::protobuf::rt::LazyV2<Authenticator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator::new)
    }
}

impl ::protobuf::Clear for Authenticator {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request {
    // message fields
    pub authenticate: ::protobuf::SingularPtrField<Authenticator_Request_Authenticate>,
    pub find: ::protobuf::SingularPtrField<Authenticator_Request_Find>,
    pub query: ::protobuf::SingularPtrField<Authenticator_Request_Query>,
    pub register: ::protobuf::SingularPtrField<Authenticator_Request_Register>,
    pub deregister: ::protobuf::SingularPtrField<Authenticator_Request_Deregister>,
    pub update: ::protobuf::SingularPtrField<Authenticator_Request_Update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request {
    fn default() -> &'a Authenticator_Request {
        <Authenticator_Request as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request {
    pub fn new() -> Authenticator_Request {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Request.Authenticate authenticate = 1;


    pub fn get_authenticate(&self) -> &Authenticator_Request_Authenticate {
        self.authenticate.as_ref().unwrap_or_else(|| <Authenticator_Request_Authenticate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authenticate(&mut self) {
        self.authenticate.clear();
    }

    pub fn has_authenticate(&self) -> bool {
        self.authenticate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticate(&mut self, v: Authenticator_Request_Authenticate) {
        self.authenticate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticate(&mut self) -> &mut Authenticator_Request_Authenticate {
        if self.authenticate.is_none() {
            self.authenticate.set_default();
        }
        self.authenticate.as_mut().unwrap()
    }

    // Take field
    pub fn take_authenticate(&mut self) -> Authenticator_Request_Authenticate {
        self.authenticate.take().unwrap_or_else(|| Authenticator_Request_Authenticate::new())
    }

    // optional .MurmurRPC.Authenticator.Request.Find find = 2;


    pub fn get_find(&self) -> &Authenticator_Request_Find {
        self.find.as_ref().unwrap_or_else(|| <Authenticator_Request_Find as ::protobuf::Message>::default_instance())
    }
    pub fn clear_find(&mut self) {
        self.find.clear();
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: Authenticator_Request_Find) {
        self.find = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut Authenticator_Request_Find {
        if self.find.is_none() {
            self.find.set_default();
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> Authenticator_Request_Find {
        self.find.take().unwrap_or_else(|| Authenticator_Request_Find::new())
    }

    // optional .MurmurRPC.Authenticator.Request.Query query = 3;


    pub fn get_query(&self) -> &Authenticator_Request_Query {
        self.query.as_ref().unwrap_or_else(|| <Authenticator_Request_Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: Authenticator_Request_Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut Authenticator_Request_Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> Authenticator_Request_Query {
        self.query.take().unwrap_or_else(|| Authenticator_Request_Query::new())
    }

    // optional .MurmurRPC.Authenticator.Request.Register register = 4;


    pub fn get_register(&self) -> &Authenticator_Request_Register {
        self.register.as_ref().unwrap_or_else(|| <Authenticator_Request_Register as ::protobuf::Message>::default_instance())
    }
    pub fn clear_register(&mut self) {
        self.register.clear();
    }

    pub fn has_register(&self) -> bool {
        self.register.is_some()
    }

    // Param is passed by value, moved
    pub fn set_register(&mut self, v: Authenticator_Request_Register) {
        self.register = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_register(&mut self) -> &mut Authenticator_Request_Register {
        if self.register.is_none() {
            self.register.set_default();
        }
        self.register.as_mut().unwrap()
    }

    // Take field
    pub fn take_register(&mut self) -> Authenticator_Request_Register {
        self.register.take().unwrap_or_else(|| Authenticator_Request_Register::new())
    }

    // optional .MurmurRPC.Authenticator.Request.Deregister deregister = 5;


    pub fn get_deregister(&self) -> &Authenticator_Request_Deregister {
        self.deregister.as_ref().unwrap_or_else(|| <Authenticator_Request_Deregister as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deregister(&mut self) {
        self.deregister.clear();
    }

    pub fn has_deregister(&self) -> bool {
        self.deregister.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deregister(&mut self, v: Authenticator_Request_Deregister) {
        self.deregister = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deregister(&mut self) -> &mut Authenticator_Request_Deregister {
        if self.deregister.is_none() {
            self.deregister.set_default();
        }
        self.deregister.as_mut().unwrap()
    }

    // Take field
    pub fn take_deregister(&mut self) -> Authenticator_Request_Deregister {
        self.deregister.take().unwrap_or_else(|| Authenticator_Request_Deregister::new())
    }

    // optional .MurmurRPC.Authenticator.Request.Update update = 6;


    pub fn get_update(&self) -> &Authenticator_Request_Update {
        self.update.as_ref().unwrap_or_else(|| <Authenticator_Request_Update as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Authenticator_Request_Update) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut Authenticator_Request_Update {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Authenticator_Request_Update {
        self.update.take().unwrap_or_else(|| Authenticator_Request_Update::new())
    }
}

impl ::protobuf::Message for Authenticator_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.authenticate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.find {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.register {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deregister {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.find)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.register)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deregister)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.authenticate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.find.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.register.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deregister.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.authenticate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.find.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.register.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deregister.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request {
        Authenticator_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Authenticate>>(
                "authenticate",
                |m: &Authenticator_Request| { &m.authenticate },
                |m: &mut Authenticator_Request| { &mut m.authenticate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Find>>(
                "find",
                |m: &Authenticator_Request| { &m.find },
                |m: &mut Authenticator_Request| { &mut m.find },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Query>>(
                "query",
                |m: &Authenticator_Request| { &m.query },
                |m: &mut Authenticator_Request| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Register>>(
                "register",
                |m: &Authenticator_Request| { &m.register },
                |m: &mut Authenticator_Request| { &mut m.register },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Deregister>>(
                "deregister",
                |m: &Authenticator_Request| { &m.deregister },
                |m: &mut Authenticator_Request| { &mut m.deregister },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Request_Update>>(
                "update",
                |m: &Authenticator_Request| { &m.update },
                |m: &mut Authenticator_Request| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request>(
                "Authenticator.Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request {
    fn clear(&mut self) {
        self.authenticate.clear();
        self.find.clear();
        self.query.clear();
        self.register.clear();
        self.deregister.clear();
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Authenticate {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    pub certificates: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    certificate_hash: ::protobuf::SingularField<::std::string::String>,
    strong_certificate: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Authenticate {
    fn default() -> &'a Authenticator_Request_Authenticate {
        <Authenticator_Request_Authenticate as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Authenticate {
    pub fn new() -> Authenticator_Request_Authenticate {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 2;


    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated bytes certificates = 3;


    pub fn get_certificates(&self) -> &[::std::vec::Vec<u8>] {
        &self.certificates
    }
    pub fn clear_certificates(&mut self) {
        self.certificates.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificates(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.certificates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_certificates(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.certificates
    }

    // Take field
    pub fn take_certificates(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.certificates, ::protobuf::RepeatedField::new())
    }

    // optional string certificate_hash = 4;


    pub fn get_certificate_hash(&self) -> &str {
        match self.certificate_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_certificate_hash(&mut self) {
        self.certificate_hash.clear();
    }

    pub fn has_certificate_hash(&self) -> bool {
        self.certificate_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_certificate_hash(&mut self, v: ::std::string::String) {
        self.certificate_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_certificate_hash(&mut self) -> &mut ::std::string::String {
        if self.certificate_hash.is_none() {
            self.certificate_hash.set_default();
        }
        self.certificate_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_certificate_hash(&mut self) -> ::std::string::String {
        self.certificate_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool strong_certificate = 5;


    pub fn get_strong_certificate(&self) -> bool {
        self.strong_certificate.unwrap_or(false)
    }
    pub fn clear_strong_certificate(&mut self) {
        self.strong_certificate = ::std::option::Option::None;
    }

    pub fn has_strong_certificate(&self) -> bool {
        self.strong_certificate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strong_certificate(&mut self, v: bool) {
        self.strong_certificate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Authenticator_Request_Authenticate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.certificates)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.certificate_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strong_certificate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.certificates {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(ref v) = self.certificate_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.strong_certificate {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.certificates {
            os.write_bytes(3, &v)?;
        };
        if let Some(ref v) = self.certificate_hash.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.strong_certificate {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Authenticate {
        Authenticator_Request_Authenticate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Authenticator_Request_Authenticate| { &m.name },
                |m: &mut Authenticator_Request_Authenticate| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &Authenticator_Request_Authenticate| { &m.password },
                |m: &mut Authenticator_Request_Authenticate| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "certificates",
                |m: &Authenticator_Request_Authenticate| { &m.certificates },
                |m: &mut Authenticator_Request_Authenticate| { &mut m.certificates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "certificate_hash",
                |m: &Authenticator_Request_Authenticate| { &m.certificate_hash },
                |m: &mut Authenticator_Request_Authenticate| { &mut m.certificate_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "strong_certificate",
                |m: &Authenticator_Request_Authenticate| { &m.strong_certificate },
                |m: &mut Authenticator_Request_Authenticate| { &mut m.strong_certificate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Authenticate>(
                "Authenticator.Request.Authenticate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Authenticate {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Authenticate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Authenticate::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Authenticate {
    fn clear(&mut self) {
        self.name.clear();
        self.password.clear();
        self.certificates.clear();
        self.certificate_hash.clear();
        self.strong_certificate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Authenticate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Authenticate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Find {
    // message fields
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Find {
    fn default() -> &'a Authenticator_Request_Find {
        <Authenticator_Request_Find as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Find {
    pub fn new() -> Authenticator_Request_Find {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Authenticator_Request_Find {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Find {
        Authenticator_Request_Find::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Authenticator_Request_Find| { &m.id },
                |m: &mut Authenticator_Request_Find| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Authenticator_Request_Find| { &m.name },
                |m: &mut Authenticator_Request_Find| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Find>(
                "Authenticator.Request.Find",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Find {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Find> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Find::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Find {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Find {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Find {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Query {
    // message fields
    filter: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Query {
    fn default() -> &'a Authenticator_Request_Query {
        <Authenticator_Request_Query as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Query {
    pub fn new() -> Authenticator_Request_Query {
        ::std::default::Default::default()
    }

    // optional string filter = 1;


    pub fn get_filter(&self) -> &str {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        self.filter.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Authenticator_Request_Query {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Query {
        Authenticator_Request_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &Authenticator_Request_Query| { &m.filter },
                |m: &mut Authenticator_Request_Query| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Query>(
                "Authenticator.Request.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Query {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Query::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Query {
    fn clear(&mut self) {
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Register {
    // message fields
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Register {
    fn default() -> &'a Authenticator_Request_Register {
        <Authenticator_Request_Register as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Register {
    pub fn new() -> Authenticator_Request_Register {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.DatabaseUser user = 1;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }
}

impl ::protobuf::Message for Authenticator_Request_Register {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Register {
        Authenticator_Request_Register::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &Authenticator_Request_Register| { &m.user },
                |m: &mut Authenticator_Request_Register| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Register>(
                "Authenticator.Request.Register",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Register {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Register> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Register::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Register {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Register {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Register {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Deregister {
    // message fields
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Deregister {
    fn default() -> &'a Authenticator_Request_Deregister {
        <Authenticator_Request_Deregister as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Deregister {
    pub fn new() -> Authenticator_Request_Deregister {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.DatabaseUser user = 1;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }
}

impl ::protobuf::Message for Authenticator_Request_Deregister {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Deregister {
        Authenticator_Request_Deregister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &Authenticator_Request_Deregister| { &m.user },
                |m: &mut Authenticator_Request_Deregister| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Deregister>(
                "Authenticator.Request.Deregister",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Deregister {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Deregister> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Deregister::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Deregister {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Deregister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Deregister {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Request_Update {
    // message fields
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Request_Update {
    fn default() -> &'a Authenticator_Request_Update {
        <Authenticator_Request_Update as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Request_Update {
    pub fn new() -> Authenticator_Request_Update {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.DatabaseUser user = 1;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }
}

impl ::protobuf::Message for Authenticator_Request_Update {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Request_Update {
        Authenticator_Request_Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &Authenticator_Request_Update| { &m.user },
                |m: &mut Authenticator_Request_Update| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Request_Update>(
                "Authenticator.Request.Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Request_Update {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Request_Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Request_Update::new)
    }
}

impl ::protobuf::Clear for Authenticator_Request_Update {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Request_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Request_Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response {
    // message fields
    pub initialize: ::protobuf::SingularPtrField<Authenticator_Response_Initialize>,
    pub authenticate: ::protobuf::SingularPtrField<Authenticator_Response_Authenticate>,
    pub find: ::protobuf::SingularPtrField<Authenticator_Response_Find>,
    pub query: ::protobuf::SingularPtrField<Authenticator_Response_Query>,
    pub register: ::protobuf::SingularPtrField<Authenticator_Response_Register>,
    pub deregister: ::protobuf::SingularPtrField<Authenticator_Response_Deregister>,
    pub update: ::protobuf::SingularPtrField<Authenticator_Response_Update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response {
    fn default() -> &'a Authenticator_Response {
        <Authenticator_Response as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response {
    pub fn new() -> Authenticator_Response {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Response.Initialize initialize = 1;


    pub fn get_initialize(&self) -> &Authenticator_Response_Initialize {
        self.initialize.as_ref().unwrap_or_else(|| <Authenticator_Response_Initialize as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initialize(&mut self) {
        self.initialize.clear();
    }

    pub fn has_initialize(&self) -> bool {
        self.initialize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialize(&mut self, v: Authenticator_Response_Initialize) {
        self.initialize = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initialize(&mut self) -> &mut Authenticator_Response_Initialize {
        if self.initialize.is_none() {
            self.initialize.set_default();
        }
        self.initialize.as_mut().unwrap()
    }

    // Take field
    pub fn take_initialize(&mut self) -> Authenticator_Response_Initialize {
        self.initialize.take().unwrap_or_else(|| Authenticator_Response_Initialize::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Authenticate authenticate = 2;


    pub fn get_authenticate(&self) -> &Authenticator_Response_Authenticate {
        self.authenticate.as_ref().unwrap_or_else(|| <Authenticator_Response_Authenticate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authenticate(&mut self) {
        self.authenticate.clear();
    }

    pub fn has_authenticate(&self) -> bool {
        self.authenticate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticate(&mut self, v: Authenticator_Response_Authenticate) {
        self.authenticate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticate(&mut self) -> &mut Authenticator_Response_Authenticate {
        if self.authenticate.is_none() {
            self.authenticate.set_default();
        }
        self.authenticate.as_mut().unwrap()
    }

    // Take field
    pub fn take_authenticate(&mut self) -> Authenticator_Response_Authenticate {
        self.authenticate.take().unwrap_or_else(|| Authenticator_Response_Authenticate::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Find find = 3;


    pub fn get_find(&self) -> &Authenticator_Response_Find {
        self.find.as_ref().unwrap_or_else(|| <Authenticator_Response_Find as ::protobuf::Message>::default_instance())
    }
    pub fn clear_find(&mut self) {
        self.find.clear();
    }

    pub fn has_find(&self) -> bool {
        self.find.is_some()
    }

    // Param is passed by value, moved
    pub fn set_find(&mut self, v: Authenticator_Response_Find) {
        self.find = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_find(&mut self) -> &mut Authenticator_Response_Find {
        if self.find.is_none() {
            self.find.set_default();
        }
        self.find.as_mut().unwrap()
    }

    // Take field
    pub fn take_find(&mut self) -> Authenticator_Response_Find {
        self.find.take().unwrap_or_else(|| Authenticator_Response_Find::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Query query = 4;


    pub fn get_query(&self) -> &Authenticator_Response_Query {
        self.query.as_ref().unwrap_or_else(|| <Authenticator_Response_Query as ::protobuf::Message>::default_instance())
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: Authenticator_Response_Query) {
        self.query = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut Authenticator_Response_Query {
        if self.query.is_none() {
            self.query.set_default();
        }
        self.query.as_mut().unwrap()
    }

    // Take field
    pub fn take_query(&mut self) -> Authenticator_Response_Query {
        self.query.take().unwrap_or_else(|| Authenticator_Response_Query::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Register register = 5;


    pub fn get_register(&self) -> &Authenticator_Response_Register {
        self.register.as_ref().unwrap_or_else(|| <Authenticator_Response_Register as ::protobuf::Message>::default_instance())
    }
    pub fn clear_register(&mut self) {
        self.register.clear();
    }

    pub fn has_register(&self) -> bool {
        self.register.is_some()
    }

    // Param is passed by value, moved
    pub fn set_register(&mut self, v: Authenticator_Response_Register) {
        self.register = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_register(&mut self) -> &mut Authenticator_Response_Register {
        if self.register.is_none() {
            self.register.set_default();
        }
        self.register.as_mut().unwrap()
    }

    // Take field
    pub fn take_register(&mut self) -> Authenticator_Response_Register {
        self.register.take().unwrap_or_else(|| Authenticator_Response_Register::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Deregister deregister = 6;


    pub fn get_deregister(&self) -> &Authenticator_Response_Deregister {
        self.deregister.as_ref().unwrap_or_else(|| <Authenticator_Response_Deregister as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deregister(&mut self) {
        self.deregister.clear();
    }

    pub fn has_deregister(&self) -> bool {
        self.deregister.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deregister(&mut self, v: Authenticator_Response_Deregister) {
        self.deregister = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deregister(&mut self) -> &mut Authenticator_Response_Deregister {
        if self.deregister.is_none() {
            self.deregister.set_default();
        }
        self.deregister.as_mut().unwrap()
    }

    // Take field
    pub fn take_deregister(&mut self) -> Authenticator_Response_Deregister {
        self.deregister.take().unwrap_or_else(|| Authenticator_Response_Deregister::new())
    }

    // optional .MurmurRPC.Authenticator.Response.Update update = 7;


    pub fn get_update(&self) -> &Authenticator_Response_Update {
        self.update.as_ref().unwrap_or_else(|| <Authenticator_Response_Update as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: Authenticator_Response_Update) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut Authenticator_Response_Update {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> Authenticator_Response_Update {
        self.update.take().unwrap_or_else(|| Authenticator_Response_Update::new())
    }
}

impl ::protobuf::Message for Authenticator_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.initialize {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.find {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.register {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deregister {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initialize)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticate)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.find)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.register)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deregister)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initialize.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authenticate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.find.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.query.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.register.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deregister.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initialize.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authenticate.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.find.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.query.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.register.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deregister.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response {
        Authenticator_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Initialize>>(
                "initialize",
                |m: &Authenticator_Response| { &m.initialize },
                |m: &mut Authenticator_Response| { &mut m.initialize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Authenticate>>(
                "authenticate",
                |m: &Authenticator_Response| { &m.authenticate },
                |m: &mut Authenticator_Response| { &mut m.authenticate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Find>>(
                "find",
                |m: &Authenticator_Response| { &m.find },
                |m: &mut Authenticator_Response| { &mut m.find },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Query>>(
                "query",
                |m: &Authenticator_Response| { &m.query },
                |m: &mut Authenticator_Response| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Register>>(
                "register",
                |m: &Authenticator_Response| { &m.register },
                |m: &mut Authenticator_Response| { &mut m.register },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Deregister>>(
                "deregister",
                |m: &Authenticator_Response| { &m.deregister },
                |m: &mut Authenticator_Response| { &mut m.deregister },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Authenticator_Response_Update>>(
                "update",
                |m: &Authenticator_Response| { &m.update },
                |m: &mut Authenticator_Response| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response>(
                "Authenticator.Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response {
    fn clear(&mut self) {
        self.initialize.clear();
        self.authenticate.clear();
        self.find.clear();
        self.query.clear();
        self.register.clear();
        self.deregister.clear();
        self.update.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Initialize {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Initialize {
    fn default() -> &'a Authenticator_Response_Initialize {
        <Authenticator_Response_Initialize as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Initialize {
    pub fn new() -> Authenticator_Response_Initialize {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }
}

impl ::protobuf::Message for Authenticator_Response_Initialize {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Initialize {
        Authenticator_Response_Initialize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &Authenticator_Response_Initialize| { &m.server },
                |m: &mut Authenticator_Response_Initialize| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Initialize>(
                "Authenticator.Response.Initialize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Initialize {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Initialize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Initialize::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Initialize {
    fn clear(&mut self) {
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Initialize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Initialize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Authenticate {
    // message fields
    status: ::std::option::Option<Authenticator_Response_Status>,
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub groups: ::protobuf::RepeatedField<ACL_Group>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Authenticate {
    fn default() -> &'a Authenticator_Response_Authenticate {
        <Authenticator_Response_Authenticate as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Authenticate {
    pub fn new() -> Authenticator_Response_Authenticate {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Response.Status status = 1;


    pub fn get_status(&self) -> Authenticator_Response_Status {
        self.status.unwrap_or(Authenticator_Response_Status::Fallthrough)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Authenticator_Response_Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .MurmurRPC.ACL.Group groups = 4;


    pub fn get_groups(&self) -> &[ACL_Group] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ACL_Group>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<ACL_Group> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ACL_Group> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Authenticator_Response_Authenticate {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.groups {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Authenticate {
        Authenticator_Response_Authenticate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Authenticator_Response_Status>>(
                "status",
                |m: &Authenticator_Response_Authenticate| { &m.status },
                |m: &mut Authenticator_Response_Authenticate| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &Authenticator_Response_Authenticate| { &m.id },
                |m: &mut Authenticator_Response_Authenticate| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Authenticator_Response_Authenticate| { &m.name },
                |m: &mut Authenticator_Response_Authenticate| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_Group>>(
                "groups",
                |m: &Authenticator_Response_Authenticate| { &m.groups },
                |m: &mut Authenticator_Response_Authenticate| { &mut m.groups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Authenticate>(
                "Authenticator.Response.Authenticate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Authenticate {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Authenticate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Authenticate::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Authenticate {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Authenticate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Authenticate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Find {
    // message fields
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Find {
    fn default() -> &'a Authenticator_Response_Find {
        <Authenticator_Response_Find as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Find {
    pub fn new() -> Authenticator_Response_Find {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.DatabaseUser user = 1;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }
}

impl ::protobuf::Message for Authenticator_Response_Find {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Find {
        Authenticator_Response_Find::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &Authenticator_Response_Find| { &m.user },
                |m: &mut Authenticator_Response_Find| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Find>(
                "Authenticator.Response.Find",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Find {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Find> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Find::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Find {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Find {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Find {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Query {
    // message fields
    pub users: ::protobuf::RepeatedField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Query {
    fn default() -> &'a Authenticator_Response_Query {
        <Authenticator_Response_Query as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Query {
    pub fn new() -> Authenticator_Response_Query {
        ::std::default::Default::default()
    }

    // repeated .MurmurRPC.DatabaseUser users = 1;


    pub fn get_users(&self) -> &[DatabaseUser] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<DatabaseUser>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseUser> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<DatabaseUser> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Authenticator_Response_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Query {
        Authenticator_Response_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "users",
                |m: &Authenticator_Response_Query| { &m.users },
                |m: &mut Authenticator_Response_Query| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Query>(
                "Authenticator.Response.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Query {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Query::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Query {
    fn clear(&mut self) {
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Register {
    // message fields
    status: ::std::option::Option<Authenticator_Response_Status>,
    pub user: ::protobuf::SingularPtrField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Register {
    fn default() -> &'a Authenticator_Response_Register {
        <Authenticator_Response_Register as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Register {
    pub fn new() -> Authenticator_Response_Register {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Response.Status status = 1;


    pub fn get_status(&self) -> Authenticator_Response_Status {
        self.status.unwrap_or(Authenticator_Response_Status::Fallthrough)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Authenticator_Response_Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional .MurmurRPC.DatabaseUser user = 2;


    pub fn get_user(&self) -> &DatabaseUser {
        self.user.as_ref().unwrap_or_else(|| <DatabaseUser as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: DatabaseUser) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut DatabaseUser {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> DatabaseUser {
        self.user.take().unwrap_or_else(|| DatabaseUser::new())
    }
}

impl ::protobuf::Message for Authenticator_Response_Register {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Register {
        Authenticator_Response_Register::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Authenticator_Response_Status>>(
                "status",
                |m: &Authenticator_Response_Register| { &m.status },
                |m: &mut Authenticator_Response_Register| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "user",
                |m: &Authenticator_Response_Register| { &m.user },
                |m: &mut Authenticator_Response_Register| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Register>(
                "Authenticator.Response.Register",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Register {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Register> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Register::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Register {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Register {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Register {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Deregister {
    // message fields
    status: ::std::option::Option<Authenticator_Response_Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Deregister {
    fn default() -> &'a Authenticator_Response_Deregister {
        <Authenticator_Response_Deregister as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Deregister {
    pub fn new() -> Authenticator_Response_Deregister {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Response.Status status = 1;


    pub fn get_status(&self) -> Authenticator_Response_Status {
        self.status.unwrap_or(Authenticator_Response_Status::Fallthrough)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Authenticator_Response_Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Authenticator_Response_Deregister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Deregister {
        Authenticator_Response_Deregister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Authenticator_Response_Status>>(
                "status",
                |m: &Authenticator_Response_Deregister| { &m.status },
                |m: &mut Authenticator_Response_Deregister| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Deregister>(
                "Authenticator.Response.Deregister",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Deregister {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Deregister> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Deregister::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Deregister {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Deregister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Deregister {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Authenticator_Response_Update {
    // message fields
    status: ::std::option::Option<Authenticator_Response_Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Authenticator_Response_Update {
    fn default() -> &'a Authenticator_Response_Update {
        <Authenticator_Response_Update as ::protobuf::Message>::default_instance()
    }
}

impl Authenticator_Response_Update {
    pub fn new() -> Authenticator_Response_Update {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Authenticator.Response.Status status = 1;


    pub fn get_status(&self) -> Authenticator_Response_Status {
        self.status.unwrap_or(Authenticator_Response_Status::Fallthrough)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Authenticator_Response_Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Authenticator_Response_Update {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Authenticator_Response_Update {
        Authenticator_Response_Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Authenticator_Response_Status>>(
                "status",
                |m: &Authenticator_Response_Update| { &m.status },
                |m: &mut Authenticator_Response_Update| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Authenticator_Response_Update>(
                "Authenticator.Response.Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Authenticator_Response_Update {
        static instance: ::protobuf::rt::LazyV2<Authenticator_Response_Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Authenticator_Response_Update::new)
    }
}

impl ::protobuf::Clear for Authenticator_Response_Update {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Authenticator_Response_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Authenticator_Response_Status {
    Fallthrough = 0,
    Success = 1,
    Failure = 2,
    TemporaryFailure = 3,
}

impl ::protobuf::ProtobufEnum for Authenticator_Response_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Authenticator_Response_Status> {
        match value {
            0 => ::std::option::Option::Some(Authenticator_Response_Status::Fallthrough),
            1 => ::std::option::Option::Some(Authenticator_Response_Status::Success),
            2 => ::std::option::Option::Some(Authenticator_Response_Status::Failure),
            3 => ::std::option::Option::Some(Authenticator_Response_Status::TemporaryFailure),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Authenticator_Response_Status] = &[
            Authenticator_Response_Status::Fallthrough,
            Authenticator_Response_Status::Success,
            Authenticator_Response_Status::Failure,
            Authenticator_Response_Status::TemporaryFailure,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Authenticator_Response_Status>("Authenticator.Response.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Authenticator_Response_Status {
}

impl ::std::default::Default for Authenticator_Response_Status {
    fn default() -> Self {
        Authenticator_Response_Status::Fallthrough
    }
}

impl ::protobuf::reflect::ProtobufValue for Authenticator_Response_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseUser {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    email: ::protobuf::SingularField<::std::string::String>,
    comment: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    last_active: ::protobuf::SingularField<::std::string::String>,
    texture: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseUser {
    fn default() -> &'a DatabaseUser {
        <DatabaseUser as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseUser {
    pub fn new() -> DatabaseUser {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string email = 4;


    pub fn get_email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    pub fn has_email(&self) -> bool {
        self.email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if self.email.is_none() {
            self.email.set_default();
        }
        self.email.as_mut().unwrap()
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        self.email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string comment = 5;


    pub fn get_comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hash = 6;


    pub fn get_hash(&self) -> &str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 7;


    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_active = 8;


    pub fn get_last_active(&self) -> &str {
        match self.last_active.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_active(&mut self) {
        self.last_active.clear();
    }

    pub fn has_last_active(&self) -> bool {
        self.last_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_active(&mut self, v: ::std::string::String) {
        self.last_active = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_active(&mut self) -> &mut ::std::string::String {
        if self.last_active.is_none() {
            self.last_active.set_default();
        }
        self.last_active.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_active(&mut self) -> ::std::string::String {
        self.last_active.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes texture = 9;


    pub fn get_texture(&self) -> &[u8] {
        match self.texture.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_texture(&mut self) {
        self.texture.clear();
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.texture.is_none() {
            self.texture.set_default();
        }
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> ::std::vec::Vec<u8> {
        self.texture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DatabaseUser {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_active)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.last_active.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.texture.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.email.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.comment.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.last_active.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.texture.as_ref() {
            os.write_bytes(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseUser {
        DatabaseUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &DatabaseUser| { &m.server },
                |m: &mut DatabaseUser| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &DatabaseUser| { &m.id },
                |m: &mut DatabaseUser| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DatabaseUser| { &m.name },
                |m: &mut DatabaseUser| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &DatabaseUser| { &m.email },
                |m: &mut DatabaseUser| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comment",
                |m: &DatabaseUser| { &m.comment },
                |m: &mut DatabaseUser| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &DatabaseUser| { &m.hash },
                |m: &mut DatabaseUser| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &DatabaseUser| { &m.password },
                |m: &mut DatabaseUser| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "last_active",
                |m: &DatabaseUser| { &m.last_active },
                |m: &mut DatabaseUser| { &mut m.last_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "texture",
                |m: &DatabaseUser| { &m.texture },
                |m: &mut DatabaseUser| { &mut m.texture },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseUser>(
                "DatabaseUser",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseUser {
        static instance: ::protobuf::rt::LazyV2<DatabaseUser> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseUser::new)
    }
}

impl ::protobuf::Clear for DatabaseUser {
    fn clear(&mut self) {
        self.server.clear();
        self.id = ::std::option::Option::None;
        self.name.clear();
        self.email.clear();
        self.comment.clear();
        self.hash.clear();
        self.password.clear();
        self.last_active.clear();
        self.texture.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseUser {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseUser_Query {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    filter: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseUser_Query {
    fn default() -> &'a DatabaseUser_Query {
        <DatabaseUser_Query as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseUser_Query {
    pub fn new() -> DatabaseUser_Query {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional string filter = 2;


    pub fn get_filter(&self) -> &str {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        self.filter.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DatabaseUser_Query {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseUser_Query {
        DatabaseUser_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &DatabaseUser_Query| { &m.server },
                |m: &mut DatabaseUser_Query| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &DatabaseUser_Query| { &m.filter },
                |m: &mut DatabaseUser_Query| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseUser_Query>(
                "DatabaseUser.Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseUser_Query {
        static instance: ::protobuf::rt::LazyV2<DatabaseUser_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseUser_Query::new)
    }
}

impl ::protobuf::Clear for DatabaseUser_Query {
    fn clear(&mut self) {
        self.server.clear();
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseUser_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseUser_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseUser_List {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub users: ::protobuf::RepeatedField<DatabaseUser>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseUser_List {
    fn default() -> &'a DatabaseUser_List {
        <DatabaseUser_List as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseUser_List {
    pub fn new() -> DatabaseUser_List {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // repeated .MurmurRPC.DatabaseUser users = 2;


    pub fn get_users(&self) -> &[DatabaseUser] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<DatabaseUser>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<DatabaseUser> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<DatabaseUser> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatabaseUser_List {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.users {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseUser_List {
        DatabaseUser_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &DatabaseUser_List| { &m.server },
                |m: &mut DatabaseUser_List| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseUser>>(
                "users",
                |m: &DatabaseUser_List| { &m.users },
                |m: &mut DatabaseUser_List| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseUser_List>(
                "DatabaseUser.List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseUser_List {
        static instance: ::protobuf::rt::LazyV2<DatabaseUser_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseUser_List::new)
    }
}

impl ::protobuf::Clear for DatabaseUser_List {
    fn clear(&mut self) {
        self.server.clear();
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseUser_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseUser_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseUser_Verify {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    name: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseUser_Verify {
    fn default() -> &'a DatabaseUser_Verify {
        <DatabaseUser_Verify as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseUser_Verify {
    pub fn new() -> DatabaseUser_Verify {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 3;


    pub fn get_password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DatabaseUser_Verify {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.password.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseUser_Verify {
        DatabaseUser_Verify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &DatabaseUser_Verify| { &m.server },
                |m: &mut DatabaseUser_Verify| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DatabaseUser_Verify| { &m.name },
                |m: &mut DatabaseUser_Verify| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &DatabaseUser_Verify| { &m.password },
                |m: &mut DatabaseUser_Verify| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseUser_Verify>(
                "DatabaseUser.Verify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseUser_Verify {
        static instance: ::protobuf::rt::LazyV2<DatabaseUser_Verify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseUser_Verify::new)
    }
}

impl ::protobuf::Clear for DatabaseUser_Verify {
    fn clear(&mut self) {
        self.server.clear();
        self.name.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseUser_Verify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseUser_Verify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectWhisperGroup {
    // message fields
    pub server: ::protobuf::SingularPtrField<Server>,
    pub user: ::protobuf::SingularPtrField<User>,
    pub source: ::protobuf::SingularPtrField<ACL_Group>,
    pub target: ::protobuf::SingularPtrField<ACL_Group>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectWhisperGroup {
    fn default() -> &'a RedirectWhisperGroup {
        <RedirectWhisperGroup as ::protobuf::Message>::default_instance()
    }
}

impl RedirectWhisperGroup {
    pub fn new() -> RedirectWhisperGroup {
        ::std::default::Default::default()
    }

    // optional .MurmurRPC.Server server = 1;


    pub fn get_server(&self) -> &Server {
        self.server.as_ref().unwrap_or_else(|| <Server as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: Server) {
        self.server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut Server {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> Server {
        self.server.take().unwrap_or_else(|| Server::new())
    }

    // optional .MurmurRPC.User user = 2;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // optional .MurmurRPC.ACL.Group source = 3;


    pub fn get_source(&self) -> &ACL_Group {
        self.source.as_ref().unwrap_or_else(|| <ACL_Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ACL_Group) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ACL_Group {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ACL_Group {
        self.source.take().unwrap_or_else(|| ACL_Group::new())
    }

    // optional .MurmurRPC.ACL.Group target = 4;


    pub fn get_target(&self) -> &ACL_Group {
        self.target.as_ref().unwrap_or_else(|| <ACL_Group as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ACL_Group) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ACL_Group {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ACL_Group {
        self.target.take().unwrap_or_else(|| ACL_Group::new())
    }
}

impl ::protobuf::Message for RedirectWhisperGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.server {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectWhisperGroup {
        RedirectWhisperGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Server>>(
                "server",
                |m: &RedirectWhisperGroup| { &m.server },
                |m: &mut RedirectWhisperGroup| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &RedirectWhisperGroup| { &m.user },
                |m: &mut RedirectWhisperGroup| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_Group>>(
                "source",
                |m: &RedirectWhisperGroup| { &m.source },
                |m: &mut RedirectWhisperGroup| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ACL_Group>>(
                "target",
                |m: &RedirectWhisperGroup| { &m.target },
                |m: &mut RedirectWhisperGroup| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedirectWhisperGroup>(
                "RedirectWhisperGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedirectWhisperGroup {
        static instance: ::protobuf::rt::LazyV2<RedirectWhisperGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedirectWhisperGroup::new)
    }
}

impl ::protobuf::Clear for RedirectWhisperGroup {
    fn clear(&mut self) {
        self.server.clear();
        self.user.clear();
        self.source.clear();
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectWhisperGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectWhisperGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16murmur/MurmurRPC.proto\x12\tMurmurRPC\"\x06\n\x04Void\"l\n\x07Vers\
    ion\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x18\n\x07rel\
    ease\x18\x02\x20\x01(\tR\x07release\x12\x0e\n\x02os\x18\x03\x20\x01(\tR\
    \x02os\x12\x1d\n\nos_version\x18\x04\x20\x01(\tR\tosVersion\"\x1c\n\x06U\
    ptime\x12\x12\n\x04secs\x18\x01\x20\x01(\x04R\x04secs\"\xa5\x04\n\x06Ser\
    ver\x12\x0e\n\x02id\x18\x01\x20\x02(\rR\x02id\x12\x18\n\x07running\x18\
    \x02\x20\x01(\x08R\x07running\x12)\n\x06uptime\x18\x03\x20\x01(\x0b2\x11\
    .MurmurRPC.UptimeR\x06uptime\x1a\x87\x03\n\x05Event\x12)\n\x06server\x18\
    \x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x120\n\x04type\x18\
    \x02\x20\x01(\x0e2\x1c.MurmurRPC.Server.Event.TypeR\x04type\x12#\n\x04us\
    er\x18\x03\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x04user\x120\n\x07message\
    \x18\x04\x20\x01(\x0b2\x16.MurmurRPC.TextMessageR\x07message\x12,\n\x07c\
    hannel\x18\x05\x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x07channel\"\x9b\x01\
    \n\x04Type\x12\x11\n\rUserConnected\x10\0\x12\x14\n\x10UserDisconnected\
    \x10\x01\x12\x14\n\x10UserStateChanged\x10\x02\x12\x13\n\x0fUserTextMess\
    age\x10\x03\x12\x12\n\x0eChannelCreated\x10\x04\x12\x12\n\x0eChannelRemo\
    ved\x10\x05\x12\x17\n\x13ChannelStateChanged\x10\x06\x1a\x07\n\x05Query\
    \x1a3\n\x04List\x12+\n\x07servers\x18\x01\x20\x03(\x0b2\x11.MurmurRPC.Se\
    rverR\x07servers\"\x8b\x01\n\x05Event\x12)\n\x06server\x18\x01\x20\x01(\
    \x0b2\x11.MurmurRPC.ServerR\x06server\x12)\n\x04type\x18\x02\x20\x01(\
    \x0e2\x15.MurmurRPC.Event.TypeR\x04type\",\n\x04Type\x12\x11\n\rServerSt\
    opped\x10\0\x12\x11\n\rServerStarted\x10\x01\"\xa8\x02\n\rContextAction\
    \x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\
    \x12\x18\n\x07context\x18\x02\x20\x01(\rR\x07context\x12\x16\n\x06action\
    \x18\x03\x20\x01(\tR\x06action\x12\x12\n\x04text\x18\x04\x20\x01(\tR\x04\
    text\x12%\n\x05actor\x18\x05\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x05actor\
    \x12#\n\x04user\x18\x06\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x04user\x12,\n\
    \x07channel\x18\x07\x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x07channel\",\n\
    \x07Context\x12\n\n\x06Server\x10\x01\x12\x0b\n\x07Channel\x10\x02\x12\
    \x08\n\x04User\x10\x04\"\xc6\x03\n\x0bTextMessage\x12)\n\x06server\x18\
    \x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12%\n\x05actor\x18\
    \x02\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x05actor\x12%\n\x05users\x18\x03\
    \x20\x03(\x0b2\x0f.MurmurRPC.UserR\x05users\x12.\n\x08channels\x18\x04\
    \x20\x03(\x0b2\x12.MurmurRPC.ChannelR\x08channels\x12(\n\x05trees\x18\
    \x05\x20\x03(\x0b2\x12.MurmurRPC.ChannelR\x05trees\x12\x12\n\x04text\x18\
    \x06\x20\x01(\tR\x04text\x1a\xcf\x01\n\x06Filter\x12)\n\x06server\x18\
    \x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12<\n\x06action\x18\
    \x02\x20\x01(\x0e2$.MurmurRPC.TextMessage.Filter.ActionR\x06action\x120\
    \n\x07message\x18\x03\x20\x01(\x0b2\x16.MurmurRPC.TextMessageR\x07messag\
    e\"*\n\x06Action\x12\n\n\x06Accept\x10\0\x12\n\n\x06Reject\x10\x01\x12\
    \x08\n\x04Drop\x10\x02\"\xd2\x02\n\x03Log\x12)\n\x06server\x18\x01\x20\
    \x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x03R\ttimestamp\x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\
    \x1aV\n\x05Query\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.Se\
    rverR\x06server\x12\x10\n\x03min\x18\x02\x20\x01(\rR\x03min\x12\x10\n\
    \x03max\x18\x03\x20\x01(\rR\x03max\x1a\x95\x01\n\x04List\x12)\n\x06serve\
    r\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12\x14\n\x05tot\
    al\x18\x02\x20\x01(\rR\x05total\x12\x10\n\x03min\x18\x03\x20\x01(\rR\x03\
    min\x12\x10\n\x03max\x18\x04\x20\x01(\rR\x03max\x12(\n\x07entries\x18\
    \x05\x20\x03(\x0b2\x0e.MurmurRPC.LogR\x07entries\"\x81\x02\n\x06Config\
    \x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\
    \x125\n\x06fields\x18\x02\x20\x03(\x0b2\x1d.MurmurRPC.Config.FieldsEntry\
    R\x06fields\x1a9\n\x0bFieldsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aZ\n\
    \x05Field\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\
    \x06server\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x03\x20\x01(\tR\x05value\"\xa1\x03\n\x07Channel\x12)\n\x06server\
    \x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12\x0e\n\x02id\
    \x18\x02\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12*\n\x06parent\x18\x04\x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x06parent\
    \x12(\n\x05links\x18\x05\x20\x03(\x0b2\x12.MurmurRPC.ChannelR\x05links\
    \x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescription\x12\x1c\n\t\
    temporary\x18\x07\x20\x01(\x08R\ttemporary\x12\x1a\n\x08position\x18\x08\
    \x20\x01(\x05R\x08position\x1a2\n\x05Query\x12)\n\x06server\x18\x01\x20\
    \x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x1aa\n\x04List\x12)\n\x06serv\
    er\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12.\n\x08chann\
    els\x18\x02\x20\x03(\x0b2\x12.MurmurRPC.ChannelR\x08channels\"\x9f\x08\n\
    \x04User\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\
    \x06server\x12\x18\n\x07session\x18\x02\x20\x01(\rR\x07session\x12\x0e\n\
    \x02id\x18\x03\x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x04\x20\x01(\tR\
    \x04name\x12\x12\n\x04mute\x18\x05\x20\x01(\x08R\x04mute\x12\x12\n\x04de\
    af\x18\x06\x20\x01(\x08R\x04deaf\x12\x1a\n\x08suppress\x18\x07\x20\x01(\
    \x08R\x08suppress\x12)\n\x10priority_speaker\x18\x08\x20\x01(\x08R\x0fpr\
    ioritySpeaker\x12\x1b\n\tself_mute\x18\t\x20\x01(\x08R\x08selfMute\x12\
    \x1b\n\tself_deaf\x18\n\x20\x01(\x08R\x08selfDeaf\x12\x1c\n\trecording\
    \x18\x0b\x20\x01(\x08R\trecording\x12,\n\x07channel\x18\x0c\x20\x01(\x0b\
    2\x12.MurmurRPC.ChannelR\x07channel\x12\x1f\n\x0bonline_secs\x18\r\x20\
    \x01(\rR\nonlineSecs\x12\x1b\n\tidle_secs\x18\x0e\x20\x01(\rR\x08idleSec\
    s\x12\"\n\rbytes_per_sec\x18\x0f\x20\x01(\rR\x0bbytesPerSec\x12,\n\x07ve\
    rsion\x18\x10\x20\x01(\x0b2\x12.MurmurRPC.VersionR\x07version\x12%\n\x0e\
    plugin_context\x18\x11\x20\x01(\x0cR\rpluginContext\x12'\n\x0fplugin_ide\
    ntity\x18\x12\x20\x01(\tR\x0epluginIdentity\x12\x18\n\x07comment\x18\x13\
    \x20\x01(\tR\x07comment\x12\x18\n\x07texture\x18\x14\x20\x01(\x0cR\x07te\
    xture\x12\x18\n\x07address\x18\x15\x20\x01(\x0cR\x07address\x12\x19\n\
    \x08tcp_only\x18\x16\x20\x01(\x08R\x07tcpOnly\x12$\n\x0eudp_ping_msecs\
    \x18\x17\x20\x01(\x02R\x0cudpPingMsecs\x12$\n\x0etcp_ping_msecs\x18\x18\
    \x20\x01(\x02R\x0ctcpPingMsecs\x1a2\n\x05Query\x12)\n\x06server\x18\x01\
    \x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x1aX\n\x04List\x12)\n\x06\
    server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12%\n\x05u\
    sers\x18\x02\x20\x03(\x0b2\x0f.MurmurRPC.UserR\x05users\x1a\x95\x01\n\
    \x04Kick\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\
    \x06server\x12#\n\x04user\x18\x02\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x04u\
    ser\x12%\n\x05actor\x18\x03\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x05actor\
    \x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\"\xe7\x01\n\x04Tree\
    \x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\
    \x12,\n\x07channel\x18\x02\x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x07chann\
    el\x12+\n\x08children\x18\x03\x20\x03(\x0b2\x0f.MurmurRPC.TreeR\x08child\
    ren\x12%\n\x05users\x18\x04\x20\x03(\x0b2\x0f.MurmurRPC.UserR\x05users\
    \x1a2\n\x05Query\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.Se\
    rverR\x06server\"\xe4\x02\n\x03Ban\x12)\n\x06server\x18\x01\x20\x01(\x0b\
    2\x11.MurmurRPC.ServerR\x06server\x12\x18\n\x07address\x18\x02\x20\x01(\
    \x0cR\x07address\x12\x12\n\x04bits\x18\x03\x20\x01(\rR\x04bits\x12\x12\n\
    \x04name\x18\x04\x20\x01(\tR\x04name\x12\x12\n\x04hash\x18\x05\x20\x01(\
    \tR\x04hash\x12\x16\n\x06reason\x18\x06\x20\x01(\tR\x06reason\x12\x14\n\
    \x05start\x18\x07\x20\x01(\x03R\x05start\x12#\n\rduration_secs\x18\x08\
    \x20\x01(\x03R\x0cdurationSecs\x1a2\n\x05Query\x12)\n\x06server\x18\x01\
    \x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x1aU\n\x04List\x12)\n\x06\
    server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12\"\n\x04\
    bans\x18\x02\x20\x03(\x0b2\x0e.MurmurRPC.BanR\x04bans\"\xf3\t\n\x03ACL\
    \x12\x1d\n\napply_here\x18\x03\x20\x01(\x08R\tapplyHere\x12\x1d\n\napply\
    _subs\x18\x04\x20\x01(\x08R\tapplySubs\x12\x1c\n\tinherited\x18\x05\x20\
    \x01(\x08R\tinherited\x12+\n\x04user\x18\x06\x20\x01(\x0b2\x17.MurmurRPC\
    .DatabaseUserR\x04user\x12*\n\x05group\x18\x07\x20\x01(\x0b2\x14.MurmurR\
    PC.ACL.GroupR\x05group\x12\x14\n\x05allow\x18\x08\x20\x01(\rR\x05allow\
    \x12\x12\n\x04deny\x18\t\x20\x01(\rR\x04deny\x1a\x96\x02\n\x05Group\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1c\n\tinherited\x18\x02\
    \x20\x01(\x08R\tinherited\x12\x18\n\x07inherit\x18\x03\x20\x01(\x08R\x07\
    inherit\x12\x20\n\x0binheritable\x18\x04\x20\x01(\x08R\x0binheritable\
    \x124\n\tusers_add\x18\x05\x20\x03(\x0b2\x17.MurmurRPC.DatabaseUserR\x08\
    usersAdd\x12:\n\x0cusers_remove\x18\x06\x20\x03(\x0b2\x17.MurmurRPC.Data\
    baseUserR\x0busersRemove\x12-\n\x05users\x18\x07\x20\x03(\x0b2\x17.Murmu\
    rRPC.DatabaseUserR\x05users\x1a\x85\x01\n\x05Query\x12)\n\x06server\x18\
    \x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12#\n\x04user\x18\
    \x02\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x04user\x12,\n\x07channel\x18\x03\
    \x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x07channel\x1a\xcb\x01\n\x04List\
    \x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\
    \x12,\n\x07channel\x18\x02\x20\x01(\x0b2\x12.MurmurRPC.ChannelR\x07chann\
    el\x12\"\n\x04acls\x18\x03\x20\x03(\x0b2\x0e.MurmurRPC.ACLR\x04acls\x12,\
    \n\x06groups\x18\x04\x20\x03(\x0b2\x14.MurmurRPC.ACL.GroupR\x06groups\
    \x12\x18\n\x07inherit\x18\x05\x20\x01(\x08R\x07inherit\x1a\xa2\x01\n\x0e\
    TemporaryGroup\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.Serv\
    erR\x06server\x12,\n\x07channel\x18\x02\x20\x01(\x0b2\x12.MurmurRPC.Chan\
    nelR\x07channel\x12#\n\x04user\x18\x03\x20\x01(\x0b2\x0f.MurmurRPC.UserR\
    \x04user\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\"\xf8\x01\n\nPerm\
    ission\x12\x08\n\x04None\x10\0\x12\t\n\x05Write\x10\x01\x12\x0c\n\x08Tra\
    verse\x10\x02\x12\t\n\x05Enter\x10\x04\x12\t\n\x05Speak\x10\x08\x12\x0c\
    \n\x07Whisper\x10\x80\x02\x12\x0e\n\nMuteDeafen\x10\x10\x12\x08\n\x04Mov\
    e\x10\x20\x12\x0f\n\x0bMakeChannel\x10@\x12\x19\n\x14MakeTemporaryChanne\
    l\x10\x80\x08\x12\x10\n\x0bLinkChannel\x10\x80\x01\x12\x10\n\x0bTextMess\
    age\x10\x80\x04\x12\n\n\x04Kick\x10\x80\x80\x04\x12\t\n\x03Ban\x10\x80\
    \x80\x08\x12\x0e\n\x08Register\x10\x80\x80\x10\x12\x12\n\x0cRegisterSelf\
    \x10\x80\x80\x20\"\xa2\x10\n\rAuthenticator\x1a\xe1\x06\n\x07Request\x12\
    Q\n\x0cauthenticate\x18\x01\x20\x01(\x0b2-.MurmurRPC.Authenticator.Reque\
    st.AuthenticateR\x0cauthenticate\x129\n\x04find\x18\x02\x20\x01(\x0b2%.M\
    urmurRPC.Authenticator.Request.FindR\x04find\x12<\n\x05query\x18\x03\x20\
    \x01(\x0b2&.MurmurRPC.Authenticator.Request.QueryR\x05query\x12E\n\x08re\
    gister\x18\x04\x20\x01(\x0b2).MurmurRPC.Authenticator.Request.RegisterR\
    \x08register\x12K\n\nderegister\x18\x05\x20\x01(\x0b2+.MurmurRPC.Authent\
    icator.Request.DeregisterR\nderegister\x12?\n\x06update\x18\x06\x20\x01(\
    \x0b2'.MurmurRPC.Authenticator.Request.UpdateR\x06update\x1a\xbc\x01\n\
    \x0cAuthenticate\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\
    \x08password\x18\x02\x20\x01(\tR\x08password\x12\"\n\x0ccertificates\x18\
    \x03\x20\x03(\x0cR\x0ccertificates\x12)\n\x10certificate_hash\x18\x04\
    \x20\x01(\tR\x0fcertificateHash\x12-\n\x12strong_certificate\x18\x05\x20\
    \x01(\x08R\x11strongCertificate\x1a*\n\x04Find\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\rR\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1a\x1f\
    \n\x05Query\x12\x16\n\x06filter\x18\x01\x20\x01(\tR\x06filter\x1a7\n\x08\
    Register\x12+\n\x04user\x18\x01\x20\x01(\x0b2\x17.MurmurRPC.DatabaseUser\
    R\x04user\x1a9\n\nDeregister\x12+\n\x04user\x18\x01\x20\x01(\x0b2\x17.Mu\
    rmurRPC.DatabaseUserR\x04user\x1a5\n\x06Update\x12+\n\x04user\x18\x01\
    \x20\x01(\x0b2\x17.MurmurRPC.DatabaseUserR\x04user\x1a\xac\t\n\x08Respon\
    se\x12L\n\ninitialize\x18\x01\x20\x01(\x0b2,.MurmurRPC.Authenticator.Res\
    ponse.InitializeR\ninitialize\x12R\n\x0cauthenticate\x18\x02\x20\x01(\
    \x0b2..MurmurRPC.Authenticator.Response.AuthenticateR\x0cauthenticate\
    \x12:\n\x04find\x18\x03\x20\x01(\x0b2&.MurmurRPC.Authenticator.Response.\
    FindR\x04find\x12=\n\x05query\x18\x04\x20\x01(\x0b2'.MurmurRPC.Authentic\
    ator.Response.QueryR\x05query\x12F\n\x08register\x18\x05\x20\x01(\x0b2*.\
    MurmurRPC.Authenticator.Response.RegisterR\x08register\x12L\n\nderegiste\
    r\x18\x06\x20\x01(\x0b2,.MurmurRPC.Authenticator.Response.DeregisterR\nd\
    eregister\x12@\n\x06update\x18\x07\x20\x01(\x0b2(.MurmurRPC.Authenticato\
    r.Response.UpdateR\x06update\x1a7\n\nInitialize\x12)\n\x06server\x18\x01\
    \x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x1a\xa2\x01\n\x0cAuthenti\
    cate\x12@\n\x06status\x18\x01\x20\x01(\x0e2(.MurmurRPC.Authenticator.Res\
    ponse.StatusR\x06status\x12\x0e\n\x02id\x18\x02\x20\x01(\rR\x02id\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12,\n\x06groups\x18\x04\x20\
    \x03(\x0b2\x14.MurmurRPC.ACL.GroupR\x06groups\x1a3\n\x04Find\x12+\n\x04u\
    ser\x18\x01\x20\x01(\x0b2\x17.MurmurRPC.DatabaseUserR\x04user\x1a6\n\x05\
    Query\x12-\n\x05users\x18\x01\x20\x03(\x0b2\x17.MurmurRPC.DatabaseUserR\
    \x05users\x1ay\n\x08Register\x12@\n\x06status\x18\x01\x20\x01(\x0e2(.Mur\
    murRPC.Authenticator.Response.StatusR\x06status\x12+\n\x04user\x18\x02\
    \x20\x01(\x0b2\x17.MurmurRPC.DatabaseUserR\x04user\x1aN\n\nDeregister\
    \x12@\n\x06status\x18\x01\x20\x01(\x0e2(.MurmurRPC.Authenticator.Respons\
    e.StatusR\x06status\x1aJ\n\x06Update\x12@\n\x06status\x18\x01\x20\x01(\
    \x0e2(.MurmurRPC.Authenticator.Response.StatusR\x06status\"I\n\x06Status\
    \x12\x0f\n\x0bFallthrough\x10\0\x12\x0b\n\x07Success\x10\x01\x12\x0b\n\
    \x07Failure\x10\x02\x12\x14\n\x10TemporaryFailure\x10\x03\"\x8b\x04\n\
    \x0cDatabaseUser\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.Se\
    rverR\x06server\x12\x0e\n\x02id\x18\x02\x20\x01(\rR\x02id\x12\x12\n\x04n\
    ame\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05email\x18\x04\x20\x01(\tR\
    \x05email\x12\x18\n\x07comment\x18\x05\x20\x01(\tR\x07comment\x12\x12\n\
    \x04hash\x18\x06\x20\x01(\tR\x04hash\x12\x1a\n\x08password\x18\x07\x20\
    \x01(\tR\x08password\x12\x1f\n\x0blast_active\x18\x08\x20\x01(\tR\nlastA\
    ctive\x12\x18\n\x07texture\x18\t\x20\x01(\x0cR\x07texture\x1aJ\n\x05Quer\
    y\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\
    \x12\x16\n\x06filter\x18\x02\x20\x01(\tR\x06filter\x1a`\n\x04List\x12)\n\
    \x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06server\x12-\n\
    \x05users\x18\x02\x20\x03(\x0b2\x17.MurmurRPC.DatabaseUserR\x05users\x1a\
    c\n\x06Verify\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.Serve\
    rR\x06server\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1a\n\x08\
    password\x18\x03\x20\x01(\tR\x08password\"\xc2\x01\n\x14RedirectWhisperG\
    roup\x12)\n\x06server\x18\x01\x20\x01(\x0b2\x11.MurmurRPC.ServerR\x06ser\
    ver\x12#\n\x04user\x18\x02\x20\x01(\x0b2\x0f.MurmurRPC.UserR\x04user\x12\
    ,\n\x06source\x18\x03\x20\x01(\x0b2\x14.MurmurRPC.ACL.GroupR\x06source\
    \x12,\n\x06target\x18\x04\x20\x01(\x0b2\x14.MurmurRPC.ACL.GroupR\x06targ\
    et2\x87\x16\n\x02V1\x12/\n\tGetUptime\x12\x0f.MurmurRPC.Void\x1a\x11.Mur\
    murRPC.Uptime\x121\n\nGetVersion\x12\x0f.MurmurRPC.Void\x1a\x12.MurmurRP\
    C.Version\x12-\n\x06Events\x12\x0f.MurmurRPC.Void\x1a\x10.MurmurRPC.Even\
    t0\x01\x122\n\x0cServerCreate\x12\x0f.MurmurRPC.Void\x1a\x11.MurmurRPC.S\
    erver\x12>\n\x0bServerQuery\x12\x17.MurmurRPC.Server.Query\x1a\x16.Murmu\
    rRPC.Server.List\x121\n\tServerGet\x12\x11.MurmurRPC.Server\x1a\x11.Murm\
    urRPC.Server\x121\n\x0bServerStart\x12\x11.MurmurRPC.Server\x1a\x0f.Murm\
    urRPC.Void\x120\n\nServerStop\x12\x11.MurmurRPC.Server\x1a\x0f.MurmurRPC\
    .Void\x122\n\x0cServerRemove\x12\x11.MurmurRPC.Server\x1a\x0f.MurmurRPC.\
    Void\x12<\n\x0cServerEvents\x12\x11.MurmurRPC.Server\x1a\x17.MurmurRPC.S\
    erver.Event0\x01\x12=\n\x10ContextActionAdd\x12\x18.MurmurRPC.ContextAct\
    ion\x1a\x0f.MurmurRPC.Void\x12@\n\x13ContextActionRemove\x12\x18.MurmurR\
    PC.ContextAction\x1a\x0f.MurmurRPC.Void\x12K\n\x13ContextActionEvents\
    \x12\x18.MurmurRPC.ContextAction\x1a\x18.MurmurRPC.ContextAction0\x01\
    \x12:\n\x0fTextMessageSend\x12\x16.MurmurRPC.TextMessage\x1a\x0f.MurmurR\
    PC.Void\x12U\n\x11TextMessageFilter\x12\x1d.MurmurRPC.TextMessage.Filter\
    \x1a\x1d.MurmurRPC.TextMessage.Filter(\x010\x01\x125\n\x08LogQuery\x12\
    \x14.MurmurRPC.Log.Query\x1a\x13.MurmurRPC.Log.List\x121\n\tConfigGet\
    \x12\x11.MurmurRPC.Server\x1a\x11.MurmurRPC.Config\x12B\n\x0eConfigGetFi\
    eld\x12\x17.MurmurRPC.Config.Field\x1a\x17.MurmurRPC.Config.Field\x12:\n\
    \x0eConfigSetField\x12\x17.MurmurRPC.Config.Field\x1a\x0f.MurmurRPC.Void\
    \x126\n\x10ConfigGetDefault\x12\x0f.MurmurRPC.Void\x1a\x11.MurmurRPC.Con\
    fig\x12A\n\x0cChannelQuery\x12\x18.MurmurRPC.Channel.Query\x1a\x17.Murmu\
    rRPC.Channel.List\x124\n\nChannelGet\x12\x12.MurmurRPC.Channel\x1a\x12.M\
    urmurRPC.Channel\x124\n\nChannelAdd\x12\x12.MurmurRPC.Channel\x1a\x12.Mu\
    rmurRPC.Channel\x124\n\rChannelRemove\x12\x12.MurmurRPC.Channel\x1a\x0f.\
    MurmurRPC.Void\x127\n\rChannelUpdate\x12\x12.MurmurRPC.Channel\x1a\x12.M\
    urmurRPC.Channel\x128\n\tUserQuery\x12\x15.MurmurRPC.User.Query\x1a\x14.\
    MurmurRPC.User.List\x12+\n\x07UserGet\x12\x0f.MurmurRPC.User\x1a\x0f.Mur\
    murRPC.User\x12.\n\nUserUpdate\x12\x0f.MurmurRPC.User\x1a\x0f.MurmurRPC.\
    User\x121\n\x08UserKick\x12\x14.MurmurRPC.User.Kick\x1a\x0f.MurmurRPC.Vo\
    id\x123\n\tTreeQuery\x12\x15.MurmurRPC.Tree.Query\x1a\x0f.MurmurRPC.Tree\
    \x124\n\x07BansGet\x12\x14.MurmurRPC.Ban.Query\x1a\x13.MurmurRPC.Ban.Lis\
    t\x12/\n\x07BansSet\x12\x13.MurmurRPC.Ban.List\x1a\x0f.MurmurRPC.Void\
    \x121\n\x06ACLGet\x12\x12.MurmurRPC.Channel\x1a\x13.MurmurRPC.ACL.List\
    \x12.\n\x06ACLSet\x12\x13.MurmurRPC.ACL.List\x1a\x0f.MurmurRPC.Void\x12B\
    \n\x1aACLGetEffectivePermissions\x12\x14.MurmurRPC.ACL.Query\x1a\x0e.Mur\
    murRPC.ACL\x12F\n\x14ACLAddTemporaryGroup\x12\x1d.MurmurRPC.ACL.Temporar\
    yGroup\x1a\x0f.MurmurRPC.Void\x12I\n\x17ACLRemoveTemporaryGroup\x12\x1d.\
    MurmurRPC.ACL.TemporaryGroup\x1a\x0f.MurmurRPC.Void\x12^\n\x13Authentica\
    torStream\x12!.MurmurRPC.Authenticator.Response\x1a\x20.MurmurRPC.Authen\
    ticator.Request(\x010\x01\x12P\n\x11DatabaseUserQuery\x12\x1d.MurmurRPC.\
    DatabaseUser.Query\x1a\x1c.MurmurRPC.DatabaseUser.List\x12C\n\x0fDatabas\
    eUserGet\x12\x17.MurmurRPC.DatabaseUser\x1a\x17.MurmurRPC.DatabaseUser\
    \x12>\n\x12DatabaseUserUpdate\x12\x17.MurmurRPC.DatabaseUser\x1a\x0f.Mur\
    murRPC.Void\x12H\n\x14DatabaseUserRegister\x12\x17.MurmurRPC.DatabaseUse\
    r\x1a\x17.MurmurRPC.DatabaseUser\x12B\n\x16DatabaseUserDeregister\x12\
    \x17.MurmurRPC.DatabaseUser\x1a\x0f.MurmurRPC.Void\x12M\n\x12DatabaseUse\
    rVerify\x12\x1e.MurmurRPC.DatabaseUser.Verify\x1a\x17.MurmurRPC.Database\
    User\x12K\n\x17RedirectWhisperGroupAdd\x12\x1f.MurmurRPC.RedirectWhisper\
    Group\x1a\x0f.MurmurRPC.Void\x12N\n\x1aRedirectWhisperGroupRemove\x12\
    \x1f.MurmurRPC.RedirectWhisperGroup\x1a\x0f.MurmurRPC.Void\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
